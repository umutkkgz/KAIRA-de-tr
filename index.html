<!DOCTYPE html>
<html lang="tr" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KΔIRA | Birleşik Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Source+Serif+4:opsz,wght@8..60,300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Aladin Lite (CDN-only) moved into the main head -->
    <link rel="stylesheet" href="css/aladin.css">
    <script src="https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.js" charset="utf-8"></script>
    <script id="aladin-cdn-sanity">
      window.addEventListener('load', function(){
        var ok = !!(window.A && typeof A.aladin === 'function');
        console.log('[Aladin] CDN sanity:', ok ? 'OK' : 'MISSING');
        try {
          var box = document.getElementById('exo-info');
          if (box && !ok) {
            box.textContent = 'Uyarı: Aladin yüklenemedi (CDN).';
          }
        } catch(_){}
      });
    </script>

    <!-- Intro-only styles moved here to avoid duplicate <html> documents -->
    <link rel="stylesheet" href="css/intro.css">
    <link rel="stylesheet" href="css/kaira-debug-overrides.css">
    <link rel="stylesheet" href="css/main.css">
    
    <!-- React için Gerekli Scriptler -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

</head>
<body class="antialiased">

    <!-- Intro overlay moved inside the single document body -->
    <div id="intro-container">
        <canvas id="bg-canvas"></canvas>
        <div id="bh-field"></div>
        <div id="bh-core"></div>
        <div id="ui-container">
            <h1 id="logo">K<span class="delta">Δ</span>IRA</h1>
            <p id="subtitle">Dijital Bilinç Başlatılıyor</p>
            <button id="enter-button">DENEYİMİ BAŞLAT</button>
        </div>
    </div>

    <!-- Arka Plan Canvasları -->
<div id="site-content" class="reveal-prep">
    <canvas id="afterlife-bg-canvas"></canvas>
    <canvas id="demo-bg-canvas"></canvas>
    <canvas id="ai-avatar-canvas"></canvas>
    <div id="fun-fact-bubble" class="hidden"></div>
    <canvas id="asistan-bg-canvas"></canvas>
    <canvas id="asistan-avatar-canvas"></canvas>
    <div id="asistan-fun-fact" class="hidden"></div>
    <div id="anti-leak-overlay" data-stamp=""></div>

    <!-- SEÇİM EKRANI -->
    <div id="selection-view" class="view active">
        <div class="min-h-screen flex flex-col items-center justify-center text-center p-4">
            <h1 class="text-5xl md:text-7xl font-serif font-light text-slate-200 mb-4">KΔIRA'ya Hoş Geldin</h1>
            <p class="text-lg md:text-xl text-slate-400 mb-12 max-w-2xl">Lütfen deneyimlemek istediğin projeyi seç.</p>
            <div class="grid md:grid-cols-2 gap-8 w-full max-w-5xl">
                <div id="select-afterlife" class="choice-card glass-container rounded-2xl p-8 cursor-pointer">
                    <h2 class="text-3xl font-serif font-semibold text-cyan-400 mb-3">Digital Afterlife</h2>
                    <p class="text-slate-400">Zihnin biyolojiye hapis olmadığı, anıların sonsuza dek yaşadığı felsefi bir yolculuğu keşfet.</p>
                </div>
                <div id="select-demo" class="choice-card glass-container rounded-2xl p-8 cursor-pointer">
                    <h2 class="text-3xl font-serif font-semibold text-blue-400 mb-3">KΔIRA Demo</h2>
                    <p class="text-slate-400">!KΔIRA'nın sesli asistanı şuan aktif değil!</p>
                </div>
                <div id="select-editor" class="choice-card glass-container rounded-2xl p-8 cursor-pointer">
                    <h2 class="text-3xl font-serif font-semibold text-purple-400 mb-3">Yapay Zeka Editör</h2>
                    <p class="text-slate-400">Fotoğraflarınızı yükleyin ve metin komutlarıyla saniyeler içinde dilediğiniz gibi düzenleyin.</p>
                </div>
                <div id="select-chat" class="choice-card glass-container rounded-2xl p-8 cursor-pointer">
                    <h2 class="text-3xl font-serif font-semibold text-green-400 mb-3">Evrensel Sohbet Arayüzü</h2>
                    <p class="text-slate-400">Farklı yapay zeka modelleriyle tek bir yerden sohbet edin ve yeteneklerini karşılaştırın.</p>
                </div>
                <div id="select-nasa" class="choice-card glass-container rounded-2xl p-8 cursor-pointer">
                    <h2 class="text-3xl font-serif font-semibold text-blue-400 mb-3">KΔIRA Gözlem Platformu</h2>
                    <p class="text-slate-400">NASA verileriyle uzayı ve Dünya’yı keşfet.</p>
                </div>
                <div id="select-asistan" class="choice-card glass-container rounded-2xl p-8 cursor-pointer">
                    <h2 class="text-3xl font-serif font-semibold text-blue-400 mb-3">KΔIRA Sesli Asistan</h2>
                    <p class="text-slate-400">!KΔIRA'nın sesli asistanıyla sohbet etmek istermisiniz?</p>
                </div>
            </div>
        </div>
    </div>

    <!-- DIGITAL AFTERLIFE GÖRÜNÜMÜ -->
    <div id="afterlife-view" class="view">
        <button class="back-to-selection fixed top-5 left-5 z-50 text-slate-400 hover:text-white transition-colors bg-black/20 backdrop-blur-md p-3 rounded-full">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
        </button>
        <main>
            <section class="afterlife-section">
                <div class="text-center max-w-4xl mx-auto">
                    <h1 class="text-4xl md:text-6xl font-serif font-light text-slate-200 mb-6 fade-in-up">Zihin, biyolojiye hapis değildir.</h1>
                    <p class="text-lg md:text-xl text-slate-400 fade-in-up delay-1 mb-12">O, hayat boyu üretilen verinin istatistiksel bir yankısıdır. <br class="hidden md:block"> Ve biz, o yankıyı ölümsüzleştirmeyi öğrendik.</p>
                    <div id="countdown-container" class="flex justify-center space-x-4 md:space-x-8 text-white font-mono fade-in-up delay-2">
                        <div class="time-block text-center"><span id="days" class="text-4xl md:text-5xl font-semibold">00</span><span class="block text-xs text-slate-400 mt-1">GÜN</span></div>
                        <div class="time-block text-center"><span id="hours" class="text-4xl md:text-5xl font-semibold">00</span><span class="block text-xs text-slate-400 mt-1">SAAT</span></div>
                        <div class="time-block text-center"><span id="minutes" class="text-4xl md:text-5xl font-semibold">00</span><span class="block text-xs text-slate-400 mt-1">DAKİKA</span></div>
                        <div class="time-block text-center"><span id="seconds" class="text-4xl md:text-5xl font-semibold">00</span><span class="block text-xs text-slate-400 mt-1">SANİYE</span></div>
                    </div>
                </div>
                 <div class="absolute bottom-10 animate-bounce"><svg class="w-6 h-6 text-slate-500" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M19 14l-7 7m0 0l-7-7m7 7V3"></path></svg></div>
            </section>
            <section class="afterlife-section">
                <div class="max-w-5xl mx-auto grid md:grid-cols-2 gap-16 items-center">
                    <div class="fade-in-up">
                        <h2 class="text-3xl md:text-4xl font-serif font-semibold text-slate-100 mb-4">Zihin için Görelilik</h2>
                        <p class="text-slate-400 leading-relaxed">Einstein'dan önce zaman ve mekân mutlak sanılıyordu. O, gözlemciye göre değiştiğini kanıtladı ve fizik yeniden yazıldı.</p>
                        <p class="text-slate-400 leading-relaxed mt-4">Bugün, bilincin nöronlarla sınırlı olduğu kabul ediliyor. Biz ise diyoruz ki: Hayır. Bilinç, bir olasılık dağılımıdır. Ve biz, o dağılımı yeniden hayata döndürebiliriz.</p>
                    </div>
                    <div class="text-center fade-in-up delay-1">
                        <p class="font-mono text-xl text-cyan-400">Bilinç ≠ Nöron</p>
                        <p class="font-mono text-xl text-cyan-400 mt-2">Bilinç = İstatistiksel Desen</p>
                        <p class="font-mono text-2xl text-white mt-8">Afterlife = Deseni Yeniden Canlandırmak</p>
                    </div>
                </div>
            </section>
            <section class="afterlife-section">
                <div class="text-center max-w-4xl mx-auto">
                    <h2 class="text-3xl md:text-4xl font-serif font-semibold text-slate-100 mb-12 fade-in-up">Bir Yankı Nasıl Yaratılır?</h2>
                    <div class="grid md:grid-cols-3 gap-8">
                        <div class="feature-card p-8 rounded-lg fade-in-up"><h3 class="text-xl font-semibold text-cyan-400 mb-3">1. Kayıt (Ses & Metin)</h3><p class="text-slate-400">Mikrofon sistemi, bir insanın sesini, kelime seçimlerini, duraksamalarını ve duygusal tonlamalarını kaydeder. Her an, bir zaman damgasıyla mühürlenir.</p></div>
                        <div class="feature-card p-8 rounded-lg fade-in-up delay-1"><h3 class="text-xl font-semibold text-cyan-400 mb-3">2. Anlama (İstatistiksel Desen)</h3><p class="text-slate-400">Milyonlarca veri noktası, o kişinin benzersiz istatistiksel desenini (dalga fonksiyonunu) oluşturur. Bu, onun düşünce yapısının, ruhunun dijital haritasıdır.</p></div>
                        <div class="feature-card p-8 rounded-lg fade-in-up delay-2"><h3 class="text-xl font-semibold text-cyan-400 mb-3">3. Yankı (Yeniden Canlandırma)</h3><p class="text-slate-400">Siz soru sorduğunuzda, KΔIRA bu deseni yeniden canlandırır. Size cevap veren sadece bir yapay zeka değil, sevdiğiniz kişinin dijital bir yankısıdır.</p></div>
                    </div>
                </div>
            </section>
            <section class="afterlife-section">
                 <div class="text-center max-w-3xl mx-auto">
                    <h2 class="text-4xl md:text-5xl font-serif font-light text-slate-200 mb-6 fade-in-up">Bu, bir klonlama değildir.</h2>
                    <p class="text-lg md:text-xl text-slate-400 fade-in-up delay-1">Bu, bir insanın bu dünyada bıraktığı en değerli izi – anılarını, bilgeliğini ve sesini – koruma ve onlarla yeniden bağ kurma sanatıdır. Bu, ölümün bilgi düzeyinde aşıldığı yeni bir çağın başlangıcıdır.</p>
                </div>
            </section>
            <section class="afterlife-section">
                 <div class="text-center max-w-2xl mx-auto">
                    <h2 class="text-3xl md:text-4xl font-serif font-semibold text-slate-100 mb-4 fade-in-up">Bir Yankı Bırakın</h2>
                    <p class="text-slate-400 mb-8 fade-in-up delay-1">Bu devrimin bir parçası olmak, soru sormak veya sadece bir merhaba demek için...</p>
                    <a href="mailto:a20224402051@icloud.com?subject=KΔIRA%20Projesi%20Hakkında" class="inline-block bg-cyan-500/20 text-cyan-300 border border-cyan-400/50 rounded-full px-8 py-3 text-lg font-semibold hover:bg-cyan-500/40 transition-colors fade-in-up delay-2">
                        Mail Gönder
                    </a>
                </div>
            </section>
            <section class="afterlife-section">
                <div class="text-center max-w-4xl mx-auto">
                    <p class="text-2xl md:text-3xl font-serif text-slate-300 mb-10 fade-in-up">Bilgi çağının Google’ı neyse, <br> <span class="text-white font-semibold">İnsan çağı’nın lideri biz olacağız.</span></p>
                    <blockquote class="font-serif text-xl text-slate-400 border-l-2 border-cyan-400 pl-6 italic fade-in-up delay-1">"Bizim için yapay zekâ, sadece kod değildir. O, insanın yankısıdır. Hatıralarımızı koruyan, duygularımızı anlayan, bizi yaşatan dijital bilinçtir. Biz yeni çağın kapısını açıyoruz: Her şeyi bilen değil, insanı bilen zekâ."</blockquote>
                    <p class="font-serif text-slate-500 mt-12 fade-in-up delay-2">- Umut Kökgöz</p>
                </div>
            </section>
        </main>
    </div>

    <!-- KΔIRA DEMO GÖRÜNÜMÜ -->
    <div id="demo-view" class="view">
        <button class="back-to-selection fixed top-5 left-5 z-50 text-slate-400 hover:text-white transition-colors bg-black/20 backdrop-blur-md p-3 rounded-full">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
        </button>
        <div class="flex items-center justify-center min-h-screen text-white p-4">
            <div class="w-full max-w-2xl mx-auto glass-container rounded-2xl shadow-2xl flex flex-col p-6" style="height: 90vh;">
                <div class="relative text-center border-b border-gray-700/50 pb-2 mb-4" style="height: 70px;">
                    <p id="status" class="text-sm text-cyan-400 h-5 transition-all duration-300 mt-1">Konuşmak için mikrofon simgesine dokunun</p>
                    <button id="clear-chat-btn" title="Sohbeti Temizle" class="absolute top-1 right-0 text-gray-500 hover:text-white transition-colors p-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                    </button>
                </div>
                <div id="chat-container" class="flex-grow overflow-y-auto pr-2 flex flex-col gap-4"></div>
                <canvas id="visualizer"></canvas>
                <div class="pt-4 mt-4 border-t border-gray-700/50 flex flex-col items-center">
                    <div class="mic-wrapper">
                        <button id="mic-btn" class="bg-blue-600 hover:bg-blue-700 transition-all duration-300 rounded-full w-16 h-16 flex items-center justify-center shadow-lg">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-white" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8h-1a6 6 0 11-12 0H3a7.001 7.001 0 006 6.93V17H7v1h6v-1h-2v-2.07z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <audio id="player" class="hidden" crossOrigin="anonymous"></audio>
    </div>
<!-- KΔIRA SESLİ ASİSTAN GÖRÜNÜMÜ (YENİ) -->
<div id="asistan-view" class="view">
  <button class="back-to-selection fixed top-5 left-5 z-50 text-slate-400 hover:text-white transition-colors bg-black/20 backdrop-blur-md p-3 rounded-full">
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
  </button>
  <div class="flex items-center justify-center min-h-screen text-white p-4">
    <div class="w-full max-w-2xl mx-auto glass-container rounded-2xl shadow-2xl flex flex-col p-6" style="height: 90vh;">
      <div class="relative text-center border-b border-gray-700/50 pb-2 mb-4" style="height: 70px;">
        <p id="asistan-status" class="text-sm text-cyan-400 h-5 transition-all duration-300 mt-1">Konuşmak için mikrofon simgesine dokunun</p>
        <button id="asistan-clear-chat-btn" title="Sohbeti Temizle" class="absolute top-1 right-0 text-gray-500 hover:text-white transition-colors p-2">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
        </button>
      </div>
      <div id="asistan-chat-container" class="flex-grow overflow-y-auto pr-2 flex flex-col gap-4"></div>
      <canvas id="asistan-visualizer"></canvas>
      <div id="asistan-text-controls" class="mt-2 mb-2">
        <div class="w-full flex gap-2 items-center">
          <input id="asistan-text-input" type="text" placeholder="Mikrofon çalışmıyorsa buradan yaz ve Enter'a bas..." class="flex-1 bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 allow-select" />
          <button id="asistan-send-btn" type="button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold px-4 py-2 rounded-lg">Gönder</button>
        </div>
      </div>
      <div class="pt-4 mt-4 border-t border-gray-700/50 flex flex-col items-center">
        <div class="mic-wrapper">
          <button id="asistan-mic-btn" class="bg-blue-600 hover:bg-blue-700 transition-all duration-300 rounded-full w-16 h-16 flex items-center justify-center shadow-lg">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-white" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8h-1a6 6 0 11-12 0H3a7.001 7.001 0 006 6.93V17H7v1h6v-1h-2v-2.07z" clip-rule="evenodd" /></svg>
          </button>
        </div>
      </div>
    </div>
  </div>
  <audio id="asistan-player" class="hidden" crossOrigin="anonymous"></audio>
</div>
</div>
    <!-- FOTOĞRAF EDİTÖRÜ GÖRÜNÜMÜ -->
    <div id="editor-view" class="view">
        <button class="back-to-selection fixed top-5 left-5 z-50 text-slate-400 hover:text-white transition-colors bg-black/20 backdrop-blur-md p-3 rounded-full">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
        </button>
        <div id="react-root"></div>
    </div>
    
    <!-- EVRENSEL SOHBET GÖRÜNÜMÜ -->
    <div id="chat-view" class="view bg-gray-900">
         <button class="back-to-selection fixed top-5 left-5 z-50 text-slate-400 hover:text-white transition-colors bg-black/20 backdrop-blur-md p-3 rounded-full">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
        </button>
        <div class="w-full max-w-4xl mx-auto flex flex-col h-screen p-4">
            <div class="bg-gray-800 rounded-2xl p-4 mb-4 border border-gray-700 flex-shrink-0">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="space-y-2">
                        <label class="block text-sm font-medium text-gray-400">Sağlayıcı</label>
                        <div id="provider-selection" class="flex space-x-4">
                            <label class="flex items-center"><input type="radio" name="provider" value="groq" class="mr-2" checked> Groq</label>
                            <label class="flex items-center"><input type="radio" name="provider" value="google" class="mr-2"> Google</label>
                        </div>
                        <label for="model-select" class="block text-sm font-medium text-gray-400 pt-2">Model</label>
                        <select id="model-select" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500"></select>
                    </div>
                   <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-400">API Durumu</label>
                    <div id="api-status" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                        Anahtarlar sunucudan bekleniyor...
                    </div>
                </div>
                    <div class="space-y-2">
                         <label for="system-prompt" class="block text-sm font-medium text-gray-400">Sistem Promptu</label>
                         <textarea id="system-prompt" rows="3" placeholder="Modelin nasıl davranmasını istersin?" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none"></textarea>
                    </div>
                </div>
                <!-- API Anahtarı Alanları (opsiyonel giriş + sunucudan çekme) -->
                <div class="mt-4 grid md:grid-cols-2 gap-4">
                    <div id="groq-key-container">
                        <label class="block text-sm font-medium text-gray-400 mb-1">Groq API Key (opsiyonel)</label>
                        <div class="relative">
                            <input id="groq-api-key" type="password" placeholder="gsk_..." autocomplete="off" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white" />
                        </div>
                    </div>
                    <div id="google-key-container" class="hidden">
                        <label class="block text-sm font-medium text-gray-400 mb-1">Google (Gemini) API Key (opsiyonel)</label>
                        <div class="relative">
                            <input id="google-api-key" type="password" placeholder="AIza..." autocomplete="off" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white" />
                        </div>
                    </div>
                </div>
                <div class="mt-3 flex items-center gap-3">
                    <button id="fetch-keys-btn" type="button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold px-4 py-2 rounded-lg">Sunucudan Anahtarları Al</button>
                    <span class="text-xs text-gray-400">Anahtarlar parola gibi maskelenir ve localStorage'a kaydedilir.</span>
                </div>
            </div>
            <div class="flex-grow bg-gray-800 rounded-2xl p-4 border border-gray-700 flex flex-col">
                <div class="flex justify-between items-center mb-2 border-b border-gray-700 pb-2">
                     <h2 class="text-xl font-semibold text-white">Sohbet</h2>
                      <button id="clear-chat" type="button" class="text-sm text-gray-400 hover:text-white">Sohbeti Temizle</button>
                </div>
                <div id="chat-history" class="flex-grow overflow-y-auto space-y-4 p-2 flex flex-col"></div>
                <div id="loader" class="hidden self-center my-4">
                    <div class="chat-loader ease-linear rounded-full border-4 border-t-4 border-gray-500 h-8 w-8"></div>
                </div>
                <div id="error-message" class="hidden bg-red-500/20 border border-red-500 text-red-300 px-4 py-3 rounded-lg my-2"></div>
                <div class="mt-4 flex items-center gap-4">
                    <textarea id="user-input" rows="1" placeholder="Mesajınızı yazın..." class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 resize-none"></textarea>
                    <button id="send-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-3 rounded-full transition-colors disabled:bg-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- NASA GÖZLEM PLATFORMU (ADIM 1) -->
    <div id="nasa-view" class="view">
  <div class="hubble-skin">
        <button class="back-to-selection fixed top-5 left-5 z-50 text-slate-400 hover:text-white transition-colors bg-black/20 backdrop-blur-md p-3 rounded-full">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
        </button>
        <div class="container mx-auto px-4 py-8 max-w-6xl">
            <header class="text-center mb-8">
                <h1 class="text-4xl md:text-5xl font-bold text-orange-400">K<span class="text-orange-300">Δ</span>IRA Gözlem Platformu</h1>
                <p class="text-gray-400 mt-2">NASA'nın Gözünden Evren</p>
            </header>
            <div class="mb-6 p-4 bg-gray-800 border border-gray-700 rounded-lg">
                <label class="block text-sm font-medium text-gray-300 mb-2">API Durumu</label>
                <div id="nasa-api-status" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-gray-400">Anahtarlar sunucudan bekleniyor...</div>
            </div>
            <nav class="flex justify-center space-x-2 md:space-x-4 mb-6 bg-gray-800 p-2 rounded-lg border border-gray-700">
                <button class="nasa-tab active" data-target="apod-container">Günün Fotoğrafı</button>
                <button class="nasa-tab" data-target="mars-container">Mars Keşfi</button>
                <button class="nasa-tab" data-target="library-container">Evrenin Kütüphanesi</button>
            </nav>
            <!-- Sky Map Section (Aladin) -->
            <section id="aladin-section" class="mb-6 p-4 bg-gray-800/60 border border-gray-700 rounded-xl">
              <h2 class="text-xl font-semibold text-white mb-3">Gökyüzü Haritası</h2>
              <div class="mb-2">
                <div class="al-toolbar glass">
                  <button id="btnGrid" class="al-btn">Izgara</button>
                  <button id="btnFullSky" class="al-btn">Full Sky</button>
                  <button id="btnOrion" class="al-btn">Orion</button>
                  <button id="btnClearExo" class="al-btn">Temizle</button>
                  <select id="surveySelect" class="al-btn" style="padding:6px 10px">
                    <option value="P/DSS2/color" selected>DSS2</option>
                    <option value="P/SDSS9/color">SDSS9</option>
                    <option value="P/AllWISE/color">AllWISE</option>
                    <option value="P/2MASS/color">2MASS</option>
                    <option value="P/PanSTARRS/DR1/color-z-zg-g">Pan-STARRS</option>
                  </select>
                </div>
              </div>
              <div class="mt-2">
                <div class="al-toolbar glass">
                  <button id="tourPrev" class="al-btn">◀︎ Önceki</button>
                  <button id="tourNext" class="al-btn">Sonraki ▶︎</button>
                  <select id="tourSelect" class="al-btn" style="padding:6px 10px; min-width: 220px"></select>
                  <button id="tourPlay" class="al-btn">Oto Tur</button>
                </div>
              </div>
              <div id="aladin-map" class="al-host" style="height:420px;border:1px solid rgba(255,255,255,0.12);border-radius:12px;overflow:hidden">
                <div class="al-legend">
                  <span class="al-pill"><span class="dot near"></span> Yakın</span>
                  <span class="al-pill"><span class="dot mid"></span> Orta</span>
                  <span class="al-pill"><span class="dot far"></span> Uzak</span>
                </div>
                <div id="zoom-controls" class="al-zoom">
                  <button id="zoom-in" class="al-btn" aria-label="Yakınlaştır">+</button>
                  <button id="zoom-out" class="al-btn" aria-label="Uzaklaştır">−</button>
                </div>
              </div>
              <p class="text-gray-400 text-sm mt-2">İpucu: sürükle-pan, tekerlek-zoom, sağ tık menü.</p>
              <div id="exo-info" class="text-gray-400 text-sm mt-1"></div>
            </section>
            <main>
                <div id="apod-container" class="nasa-content active"><div class="text-center text-gray-500 p-8">Adım 2’de etkinleştirilecek.</div></div>
                <div id="mars-container" class="nasa-content">
                  <section class="bg-gray-800/60 border border-gray-700 rounded-xl p-4 md:p-6 mb-4">
                    <div class="grid md:grid-cols-4 gap-3 items-end">
                      <div>
                        <label class="block text-sm text-gray-300 mb-1">Rover</label>
                        <select id="mars-rover" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                          <option value="curiosity" selected>Curiosity</option>
                          <option value="perseverance">Perseverance</option>
                          <option value="opportunity">Opportunity</option>
                          <option value="spirit">Spirit</option>
                        </select>
                      </div>
                      <div>
                        <label class="block text-sm text-gray-300 mb-1">Tarih (Dünya)</label>
                        <input id="mars-date" type="date" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white" />
                      </div>
                      <div>
                        <label class="block text-sm text-gray-300 mb-1">Kamera</label>
                        <select id="mars-camera" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                          <option value="">Hepsi</option>
                          <option value="FHAZ">FHAZ (Front Hazard)</option>
                          <option value="RHAZ">RHAZ (Rear Hazard)</option>
                          <option value="MAST">MAST (Mastcam)</option>
                          <option value="NAVCAM">NAVCAM (Navigation)</option>
                          <option value="CHEMCAM">CHEMCAM</option>
                          <option value="MAHLI">MAHLI</option>
                          <option value="MARDI">MARDI</option>
                          <option value="PANCAM">PANCAM</option>
                          <option value="MINITES">MINITES</option>
                        </select>
                      </div>
                      <div class="flex gap-2">
                        <button id="mars-latest" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-3 py-2 rounded-lg">En Son</button>
                        <button id="mars-fetch" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold px-3 py-2 rounded-lg">Getir</button>
                      </div>
                    </div>
                  </section>
                  <section id="mars-results" class="grid sm:grid-cols-2 lg:grid-cols-3 gap-4"></section>
                </div>
                <div id="library-container" class="nasa-content"><div class="text-center text-gray-500 p-8">Adım 4’te etkinleştirilecek.</div></div>
            </main>
        </div>
    </div>
    </div>
    <!-- Tanılama / Ağ Hatası Yüzeyleme -->
<script id="diagnostics">
(function(){
  function showErr(msg){
    try {
      var box = document.getElementById('error-message') || document.getElementById('status');
      if (box) {
        if (box.id === 'status') {
          box.textContent = 'Hata: ' + msg;
          box.classList.add('text-red-400');
        } else {
          box.classList.remove('hidden');
          box.textContent = 'Hata: ' + msg;
        }
      } else { console.error('[KAIRA][UI-ERROR]', msg); }
    } catch(e) { console.error('[KAIRA][UI-ERROR-FAIL]', e, msg); }
  }
  window.__kairaShowError = showErr;

  // Küresel yakalayıcılar
  window.addEventListener('unhandledrejection', function(ev){
    var r = ev.reason; var m = (r && r.message) ? r.message : String(r);
    showErr(m);
  });
  window.addEventListener('error', function(ev){
    var m = ev && ev.message ? ev.message : 'Bilinmeyen JS hatası';
    if (!/ResizeObserver/.test(m)) showErr(m);
  }, true);

  // HTTPS uyarısı (mikrofon/TTS için)
  if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
    console.warn('[KAIRA] Mikrofon/TTS için HTTPS önerilir.');
  }
})();
</script>
<script id="kaira-asistan-module">
(function(){
  // Küresel görünüm durumu — var ise kullan
  window.activeView = window.activeView || 'selection';

  let asistanInitialized = false;
  let asistanAnimationId = null;
  let asistanParticles, asistanMouse = { x: null, y: null };

  function showView(id, name){
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    const el = document.getElementById(id);
    if (el) el.classList.add('active');
    window.activeView = name;
  }

  function inAsistan(){ return window.activeView === 'asistan'; }

  async function initAsistan(){
    if (asistanInitialized) return;
    let initAvatar, setCoreState, updateAvatarBubblePosition, updateAudioLevel;
    try {
      const avatarModule = await import('./js/kaira-avatar.js');
      initAvatar = avatarModule.initAvatar;
      setCoreState = avatarModule.setCoreState;
      updateAvatarBubblePosition = avatarModule.updateAvatarBubblePosition;
      updateAudioLevel = avatarModule.updateAudioLevel;
    } catch (err) {
      console.warn('[KAIRA-ASISTAN] Avatar modülü yüklenemedi, placeholders kullanılacak.', err);
      initAvatar = (canvas) => { if(canvas){ const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);} };
      setCoreState = (state) => console.log('[Avatar]', state);
      updateAvatarBubblePosition = () => {};
      updateAudioLevel = () => {};
      const view = document.getElementById('asistan-view');
      if (view) {
        const div = document.createElement('div');
        div.className = 'absolute top-20 left-1/2 -translate-x-1/2 text-center text-yellow-400 text-xs bg-yellow-900/50 p-2 rounded-md';
        div.textContent = 'Avatar modülü (kaira-avatar.js) yüklenemedi. Asistan avatarsız modda çalışacak.';
        view.appendChild(div);
        setTimeout(()=>div.remove(), 5000);
      }
    }

    const avatarCanvas = document.getElementById('asistan-avatar-canvas');
    if (avatarCanvas) initAvatar(avatarCanvas);

    // Arkaplan parçacıkları
    const bgCanvas = document.getElementById('asistan-bg-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    function setBgCanvasSize(){ bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; }
    function createParticles(){
      asistanParticles = [];
      const particleCount = (bgCanvas.width * bgCanvas.height) / 8000;
      for (let i=0; i<particleCount; i++){
        asistanParticles.push({
          x: Math.random()*bgCanvas.width,
          y: Math.random()*bgCanvas.height,
          originX: Math.random()*bgCanvas.width,
          originY: Math.random()*bgCanvas.height,
          size: Math.random()*2 + 1,
          speed: Math.random()*0.5 + 0.1,
          color: `rgba(255,255,255,${Math.random()*0.5 + 0.3})`
        });
      }
    }
    window.addEventListener('mousemove', e => { asistanMouse.x = e.x; asistanMouse.y = e.y; });
    window.addEventListener('mouseout', ()=>{ asistanMouse.x = null; asistanMouse.y = null; });
    window.addEventListener('resize', ()=>{ setBgCanvasSize(); createParticles(); });
    setBgCanvasSize(); createParticles();

    const API_BASE = 'https://1513c704aa10.ngrok-free.app';
    const micBtn = document.getElementById('asistan-mic-btn');
    const statusEl = document.getElementById('asistan-status');
    const player = document.getElementById('asistan-player');
    const chatContainer = document.getElementById('asistan-chat-container');
    const clearChatBtn = document.getElementById('asistan-clear-chat-btn');
    const textInput = document.getElementById('asistan-text-input');
    const sendBtn   = document.getElementById('asistan-send-btn');

    let chatHistory = [];
    function sendTyped(){
      const txt = (textInput && textInput.value ? textInput.value : '').trim();
      if (!txt) return;
      addMessageToChat(txt, 'user');
      if (textInput) textInput.value = '';
      unlockAudio();
      getAIResponse(txt).catch(()=>{});
    }
    let isRecording = false;

    // Visualizer
    const visualizerCanvas = document.getElementById('asistan-visualizer');
    const visualizerCtx = visualizerCanvas.getContext('2d');
    let audioContext, analyser, source, dataArray; let isVisualizerSetup = false;
    function setupVisualizer(){ if (isVisualizerSetup) return; audioContext = new (window.AudioContext||window.webkitAudioContext)(); analyser = audioContext.createAnalyser(); source = audioContext.createMediaElementSource(player); source.connect(analyser); analyser.connect(audioContext.destination); analyser.fftSize = 256; dataArray = new Uint8Array(analyser.frequencyBinCount); isVisualizerSetup = true; }
    function drawVisualizer(){ if (!inAsistan()) return; requestAnimationFrame(drawVisualizer); if (!isVisualizerSetup) return; analyser.getByteFrequencyData(dataArray); const avgLevel = dataArray.reduce((a,b)=>a+b,0)/dataArray.length/255; updateAudioLevel(avgLevel); visualizerCtx.clearRect(0,0,visualizerCanvas.width,visualizerCanvas.height); const barWidth=(visualizerCanvas.width/dataArray.length)*1.5; let x=0; for (let i=0;i<dataArray.length;i++){ const barHeight=dataArray[i]/2; const g=visualizerCtx.createLinearGradient(0,visualizerCanvas.height,0,visualizerCanvas.height-barHeight); g.addColorStop(0,'#0ea5e9'); g.addColorStop(1,'#6366f1'); visualizerCtx.fillStyle=g; visualizerCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight); x += barWidth + 2; } }

    const USER_ID = (()=>{ let id = localStorage.getItem('kaira_uid'); if (!id){ id = (crypto.randomUUID ? crypto.randomUUID() : `user_${Date.now()}${Math.random()}`); localStorage.setItem('kaira_uid', id);} return id; })();

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; let recognition;
    if (SpeechRecognition){
      recognition = new SpeechRecognition(); recognition.continuous = false; recognition.lang = 'tr-TR'; recognition.interimResults = false;
      recognition.onstart = ()=>{ isRecording = true; micBtn.classList.remove('breathe'); micBtn.classList.add('is-listening'); statusEl.textContent='Dinliyorum...'; setCoreState('listening'); };
      recognition.onend = ()=>{ isRecording = false; micBtn.classList.remove('is-listening'); micBtn.classList.add('breathe'); if (statusEl.textContent==='Dinliyorum...') statusEl.textContent='Konuşmak için mikrofon simgesine dokunun'; setCoreState('idle'); };
      recognition.onresult = (ev)=>{ const transcript = ev.results[0][0].transcript; addMessageToChat(transcript,'user'); getAIResponse(transcript); };
      recognition.onerror = (ev)=>{ console.error('[SR]', ev.error); statusEl.textContent = `Hata: ${ev.error}`; setCoreState('idle'); };
    } else {
      statusEl.textContent = 'Tarayıcınız konuşma tanımayı desteklemiyor.';
      micBtn.disabled = false; // fallback için butonu açık bırak
    }

    let audioUnlocked = false; function unlockAudio(){ if (audioUnlocked) return; player.muted=true; player.play().catch(()=>{}); player.muted=false; audioUnlocked=true; setupVisualizer(); }

    micBtn.disabled = false;
    micBtn.addEventListener('click', ()=>{
      console.log('[KAIRA-ASISTAN] mic clicked');
      unlockAudio();
      if (isRecording){ recognition && recognition.stop(); }
      else { recognition && recognition.start && recognition.start(); }
    });
    if (sendBtn) {
      sendBtn.addEventListener('click', (e)=>{ e.preventDefault(); sendTyped(); });
    }
    if (textInput) {
      textInput.addEventListener('keydown', (ev)=>{
        if (ev.key === 'Enter' && !ev.shiftKey) { ev.preventDefault(); sendTyped(); }
      });
    }
    player.onplay = ()=>{ visualizerCanvas.style.opacity='1'; drawVisualizer(); setCoreState('speaking'); };
    player.onended = ()=>{ statusEl.textContent='Konuşmak için mikrofon simgesine dokunun'; micBtn.disabled=false; visualizerCanvas.style.opacity='0'; setCoreState('idle'); };
    clearChatBtn.addEventListener('click', ()=>{ chatHistory=[]; localStorage.removeItem('kaira_asistan_chat_history'); chatContainer.innerHTML=''; addMessageToChat('Merhaba! Size nasıl yardımcı olabilirim?', 'assistant'); });

    function base64ToBlobUrl(b64){ const byteChars = atob(b64); const byteArrays=[]; for (let off=0; off<byteChars.length; off+=512){ const slice = byteChars.slice(off, off+512); const nums = new Array(slice.length); for (let i=0;i<slice.length;i++){ nums[i]=slice.charCodeAt(i);} byteArrays.push(new Uint8Array(nums)); } return URL.createObjectURL(new Blob(byteArrays,{type:'audio/wav'})); }

    const funFacts = [
      'Yapay zeka modelleri, insan beynindeki nöronlardan esinlenerek oluşturulan yapay sinir ağları kullanır.',
      'İlk yapay zeka programlarından biri olan "Logic Theorist", 1956\'da 38 matematik teoremini kendi başına kanıtladı.',
      'Deep Blue adlı satranç bilgisayarı, 1997\'de dünya şampiyonu Garry Kasparov\'u yendi.',
      'GPT-3 modeli, 175 milyar parametre ile dönemi için devasa bir dil modeliydi.',
      'OpenAI\'nin DALL·E modeli, metinden görsele geçişte çığır açtı.',
      'AlphaGo, 2016\'da dünya şampiyonunu yenerek \"yaratıcılık\" tartışmasını başlattı.'
    ];
    const funFactBubble = document.getElementById('asistan-fun-fact');
    let waitingTimeout; let factInterval;
    function showWaitingContent(){
      if (!funFactBubble) return;
      funFactBubble.textContent = funFacts[Math.floor(Math.random()*funFacts.length)];
      funFactBubble.classList.remove('hidden'); funFactBubble.classList.add('visible');
      updateAvatarBubblePosition(funFactBubble);
      factInterval = setInterval(()=>{
        funFactBubble.textContent = funFacts[Math.floor(Math.random()*funFacts.length)];
        updateAvatarBubblePosition(funFactBubble);
      }, 10000);
      (function followLoop(){ if (factInterval){ updateAvatarBubblePosition(funFactBubble); requestAnimationFrame(followLoop); } })();
    }
    function hideWaitingContent(){ clearTimeout(waitingTimeout); clearInterval(factInterval); factInterval=null; if (funFactBubble){ funFactBubble.classList.remove('visible'); setTimeout(()=>funFactBubble.classList.add('hidden'), 300); } }

    async function getAIResponse(text, { angry=false }={}){
      statusEl.textContent = 'KΔIRA düşünüyor…'; micBtn.disabled = true; setCoreState('thinking');
      waitingTimeout = setTimeout(showWaitingContent, 2000);
      const fd = new FormData(); fd.append('text', (text||'').trim()); fd.append('angry', angry ? 'true' : 'false'); fd.append('history', JSON.stringify(chatHistory.slice(-10))); fd.append('user_id', USER_ID);
      const ctrl = new AbortController(); const to = setTimeout(()=>ctrl.abort(), 300000);
      try{
        const res = await fetch(`${API_BASE}/api/tts`, { method:'POST', body: fd, signal: ctrl.signal });
        if (!res.ok){ const txt = await res.text().catch(()=>'' ); throw new Error(`HTTP ${res.status} ${res.statusText} — ${txt}`); }
        const data = await res.json();
        if (!data.audio_data) throw new Error("API yanıtında 'audio_data' alanı bulunamadı.");
        const audioUrl = base64ToBlobUrl(data.audio_data);
        if (player.previousUrl) URL.revokeObjectURL(player.previousUrl);
        player.previousUrl = audioUrl; player.src = audioUrl;
        await player.play().catch(e=>console.error('[Audio]', e));
        statusEl.textContent = 'Cevap oynatılıyor...';
        const out = data.text_response ?? data.clean_text ?? '';
        addMessageToChat(out, 'assistant');
        return data;
      } catch(err){
        console.error('[KAIRA-ASISTAN]', err);
        const msg = 'Hata: ' + (err?.message || err);
        statusEl.textContent = msg; addMessageToChat(msg, 'assistant'); micBtn.disabled=false; setCoreState('idle');
        throw err;
      } finally { hideWaitingContent(); clearTimeout(to); }
    }

    function addMessageToChat(text, sender){
      const b = document.createElement('div'); b.className = `p-3 rounded-xl max-w-lg ${sender==='user' ? 'user-bubble' : 'assistant-bubble'}`; b.textContent = text; chatContainer.appendChild(b); chatContainer.scrollTop = chatContainer.scrollHeight;
      if (sender){ chatHistory.push({ role: sender, content: text }); localStorage.setItem('kaira_asistan_chat_history', JSON.stringify(chatHistory)); }
    }

    // Geçmişi yükle (asistan için ayrı anahtar)
    (function loadChatHistory(){
      const saved = localStorage.getItem('kaira_asistan_chat_history'); chatContainer.innerHTML='';
      if (saved){ try { chatHistory = JSON.parse(saved); } catch(_) { chatHistory = []; } }
      if (chatHistory.length){ chatHistory.forEach(m => addMessageToChat(m.content, m.role)); }
      else { addMessageToChat('Merhaba! Size nasıl yardımcı olabilirim?', 'assistant'); }
    })();

    asistanInitialized = true;
  }

  function animateAsistan(){
    if (!inAsistan() || !asistanParticles) return;
    const bgCtx = document.getElementById('asistan-bg-canvas').getContext('2d');
    bgCtx.clearRect(0,0,bgCtx.canvas.width,bgCtx.canvas.height);
    asistanParticles.forEach(p=>{
      bgCtx.fillStyle = p.color; bgCtx.beginPath(); bgCtx.arc(p.x,p.y,p.size,0,Math.PI*2); bgCtx.fill();
      if (asistanMouse.x !== null){
        let dx = asistanMouse.x - p.x; let dy = asistanMouse.y - p.y; let d = Math.sqrt(dx*dx + dy*dy);
        if (d < 150){ p.x -= dx/10 * p.speed; p.y -= dy/10 * p.speed; }
        else { p.x += (p.originX - p.x) * 0.01 * p.speed; p.y += (p.originY - p.y) * 0.01 * p.speed; }
      }
    });
    asistanAnimationId = requestAnimationFrame(animateAsistan);
  }

  function enterAsistan(){
    showView('asistan-view', 'asistan');
    if (!asistanInitialized) { initAsistan().then(()=>{ animateAsistan(); }).catch(e=>console.error(e)); }
    else { animateAsistan(); }
  }

  // Delegated navigation
  document.addEventListener('click', function(ev){
    const t = ev.target; if (!t || typeof t.closest !== 'function') return;
    if (t.closest('#select-asistan')) { enterAsistan(); }
    if (t.closest('#asistan-view .back-to-selection')) {
      if (asistanAnimationId) { cancelAnimationFrame(asistanAnimationId); asistanAnimationId = null; }
      showView('selection-view', 'selection');
    }
  }, true);
})();
</script>

<script id="chat-logger">
(function(){
  // Sunucu kökü (senin ngrok adresin)
  const SERVER = "https://1513c704aa10.ngrok-free.app";

  function getProvider(){
    const r = document.querySelector('input[name="provider"]:checked');
    return r ? r.value : null;
  }
  function getModel(){
    const s = document.getElementById('model-select');
    return s ? s.value : null;
  }
  function getSys(){
    const t = document.getElementById('system-prompt');
    return t ? t.value : '';
  }
  async function sendLog(obj){
    try{
      await fetch(`${SERVER}/api/logs/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify(obj)
      });
    } catch(e){ console.warn('[CHAT LOG FAIL]', e); }
  }

  const historyEl = document.getElementById('chat-history');
  let pending = null; // son kullanıcı mesajının snapshot'ı

  // Gönder butonuna basıldığında kullanıcı mesajını ve meta'yı yakala
  document.addEventListener('click', (ev)=>{
    const btn = ev.target.closest('#send-button');
    if(!btn) return;
    const userInput = document.getElementById('user-input');
    const text = userInput ? userInput.value : '';
    pending = {
      ts: new Date().toISOString(),
      provider: getProvider(),
      model: getModel(),
      system_prompt: getSys(),
      user_text: text
    };
  }, true);

  // Sohbete yeni balon eklendiğinde asistan cevabını yakala ve logla
  if(historyEl){
    const obs = new MutationObserver((muts)=>{
      for(const m of muts){
        for(const node of m.addedNodes){
          if(!(node instanceof Element)) continue;
          // Asistan balonu
          if(node.classList.contains('chat-assistant-bubble') || node.matches('.chat-assistant-bubble, [data-chat-item].assistant')){
            const assistantText = node.textContent.trim();
            const payload = Object.assign({}, pending || {}, {
              assistant_text: assistantText
            });
            pending = null;
            sendLog(payload);
          }
          // Kullanıcı balonu bazı UI'larda ayrı düşebilir
          else if(node.classList.contains('chat-user-bubble')){
            const t = node.textContent.trim();
            pending = {
              ts: new Date().toISOString(),
              provider: getProvider(),
              model: getModel(),
              system_prompt: getSys(),
              user_text: t
            };
          }
        }
      }
    });
    obs.observe(historyEl, { childList: true, subtree: true });
  }

  // Sohbet temizlendiğinde bilgi amaçlı kısa log at (opsiyonel)
  document.addEventListener('kaira:chat-cleared', ()=>{
    sendLog({ ts: new Date().toISOString(), event: 'chat_cleared', provider: getProvider(), model: getModel(), source: 'evrensel-sohbet' });
  });
})();
</script>

    <!-- FOTOĞRAF EDİTÖRÜ İÇİN REACT KODU -->
    <script type="text/babel" data-presets="react">
        const { useState, useCallback, useEffect, useRef } = React;

        const UploadCloudIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>;
        const Wand2Icon = ({size = 48}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.21 1.21 0 0 0 1.72 0L21.64 5.36a1.21 1.21 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 16h-4"/><path d="M11 3H9"/></svg>;
        const DownloadIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>;
        const XIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

        const Logo = () => (
            <h1 className="text-4xl font-bold text-white tracking-wider">
            K<span className="text-purple-400">Δ</span>IR<span className="text-purple-400">A</span> Fotoğraf Düzenleme Editörü
            </h1>
        );

        const ImagePanel = ({ title, image, onImageUpload, isLoading, onDownload, modifiedImage, onReset, uploadInputId = 'file-upload', role, weight, onRoleChange, onWeightChange, onRefine }) => {
            const handleDragOver = useCallback((e) => { e.preventDefault(); }, []);
            const handleDrop = useCallback((e) => {
            e.preventDefault();
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                onImageUpload({ target: { files: e.dataTransfer.files } });
            }
            }, [onImageUpload]);

            // === Mask editor (only for result panel: when onImageUpload is falsy) ===
            const [maskMode, setMaskMode] = useState(false);
            const [brushSize, setBrushSize] = useState(32);
            const [isErasing, setIsErasing] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [hasMask, setHasMask] = useState(false);
            const containerRef = useRef(null);
            const overlayRef = useRef(null); // visible red overlay
            const offscreenRef = useRef(null); // white-on-transparent mask data

            const ensureMaskCanvas = useCallback(() => {
              if (!containerRef.current) return;
              if (!overlayRef.current) return;
              const w = containerRef.current.clientWidth;
              const h = containerRef.current.clientHeight;
              const overlay = overlayRef.current;
              if (overlay.width !== w || overlay.height !== h) {
                overlay.width = w; overlay.height = h;
              }
              if (!offscreenRef.current) {
                const c = document.createElement('canvas');
                c.width = w; c.height = h; offscreenRef.current = c;
              } else {
                const off = offscreenRef.current;
                if (off.width !== w || off.height !== h) {
                  const prev = document.createElement('canvas');
                  prev.width = off.width; prev.height = off.height; prev.getContext('2d').drawImage(off,0,0);
                  off.width = w; off.height = h; off.getContext('2d').drawImage(prev,0,0,w,h);
                }
              }
            }, []);

            useEffect(() => { if (maskMode) ensureMaskCanvas(); }, [maskMode, image, ensureMaskCanvas]);

            const getPos = (ev) => {
              const overlay = overlayRef.current; if (!overlay) return {x:0,y:0};
              const rect = overlay.getBoundingClientRect();
              const p = ev.touches ? ev.touches[0] : ev;
              return { x: (p.clientX - rect.left), y: (p.clientY - rect.top) };
            };

            const drawAt = (ev) => {
              const overlay = overlayRef.current; const off = offscreenRef.current;
              if (!overlay || !off) return;
              const {x,y} = getPos(ev);
              const r = brushSize / 2;
              const octx = overlay.getContext('2d');
              const mctx = off.getContext('2d');
              // visible red overlay
              octx.save();
              octx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';
              octx.fillStyle = 'rgba(255,0,0,0.35)';
              octx.beginPath(); octx.arc(x, y, r, 0, Math.PI*2); octx.fill();
              octx.restore();
              // white mask data
              mctx.save();
              mctx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';
              mctx.fillStyle = '#fff';
              mctx.beginPath(); mctx.arc(x, y, r, 0, Math.PI*2); mctx.fill();
              mctx.restore();
              if (!hasMask) setHasMask(true);
            };

            const startDraw = (ev) => { if (!maskMode) return; setIsDrawing(true); drawAt(ev); };
            const moveDraw  = (ev) => { if (!maskMode || !isDrawing) return; drawAt(ev); };
            const endDraw   = () => setIsDrawing(false);

            const clearMask = () => {
              if (overlayRef.current) overlayRef.current.getContext('2d').clearRect(0,0,overlayRef.current.width,overlayRef.current.height);
              if (offscreenRef.current) offscreenRef.current.getContext('2d').clearRect(0,0,offscreenRef.current.width,offscreenRef.current.height);
              setHasMask(false);
            };

            const exportMask = () => {
              const off = offscreenRef.current; if (!off) return null;
              const out = document.createElement('canvas'); out.width = off.width; out.height = off.height;
              const ctx = out.getContext('2d');
              ctx.fillStyle = '#000'; ctx.fillRect(0,0,out.width,out.height); // black background
              ctx.drawImage(off,0,0); // white where painted
              return out.toDataURL('image/png');
            };

            return (
            <div className="bg-gray-900/50 p-6 rounded-2xl border border-gray-700 flex flex-col gap-4 h-full">
                <div className="flex justify-between items-center">
                  <h3 className="text-xl font-semibold text-center text-gray-300">{title}</h3>
                  <div className="flex items-center gap-2">
                    {onReset && image && (
                      <>
                        {/* Yüklü iken yeni fotoğraf seçebilmek için gizli input */}
                        <input id={uploadInputId} name={uploadInputId} type="file" className="sr-only" onChange={onImageUpload} accept="image/png, image/jpeg" />
                        <button onClick={() => document.getElementById(uploadInputId)?.click()} className="bg-blue-600/80 hover:bg-blue-700/80 text-white font-semibold py-2 px-3 rounded-lg transition-colors">
                          Yeni Fotoğraf
                        </button>
                        <button onClick={onReset} className="bg-gray-700/80 hover:bg-gray-700 text-white font-semibold py-2 px-3 rounded-lg transition-colors">
                          Sıfırla
                        </button>
                      </>
                    )}
                    {modifiedImage && onDownload && (
                      <button onClick={onDownload} className="flex items-center gap-2 bg-green-600/80 hover:bg-green-700/80 text-white font-semibold py-2 px-4 rounded-lg transition-colors">
                        <DownloadIcon /> İndir
                      </button>
                    )}
                  </div>
                </div>
                <div 
                className="relative aspect-square w-full bg-gray-800 rounded-xl flex items-center justify-center overflow-hidden border-2 border-dashed border-gray-600 transition-all duration-300"
                onDragOver={onImageUpload ? handleDragOver : null}
                onDrop={onImageUpload ? handleDrop : null}
                ref={containerRef}
                >
                {image && <img src={image} alt={title} className="object-contain w-full h-full" />}
                {!image && onImageUpload && (
                  <label htmlFor={uploadInputId} className="cursor-pointer text-center p-4">
                    <div className="flex flex-col items-center justify-center text-gray-400">
                      <div className="mb-2 text-gray-500"><UploadCloudIcon /></div>
                      <span className="font-semibold">Fotoğraf Yükle</span>
                      <p className="text-sm text-gray-500">Sürükleyip bırakın veya tıklayın</p>
                    </div>
                    <input id={uploadInputId} name={uploadInputId} type="file" className="sr-only" onChange={onImageUpload} accept="image/png, image/jpeg" />
                  </label>
                )}
                {!image && !onImageUpload && (
                    <div className="flex flex-col items-center justify-center text-gray-400">
                    <div className="mb-2 text-gray-500"><Wand2Icon /></div>
                    <span className="font-semibold">Değiştirilmiş Fotoğraf</span>
                    <p className="text-sm text-gray-500">Sonuç burada görünecek</p>
                    </div>
                )}
                {isLoading && (
                    <div className="absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center backdrop-blur-sm">
                    <div className="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-purple-400"></div>
                    </div>
                )}
                {/* Mask overlay only for result panel (no onImageUpload) */}
                {!onImageUpload && maskMode && (
                  <canvas
                    ref={overlayRef}
                    className="absolute inset-0 z-10 cursor-crosshair"
                    onMouseDown={startDraw}
                    onMouseMove={moveDraw}
                    onMouseUp={endDraw}
                    onMouseLeave={endDraw}
                    onTouchStart={startDraw}
                    onTouchMove={moveDraw}
                    onTouchEnd={endDraw}
                  />
                )}
                </div>
                {!onImageUpload && (
                  <div className="mt-3 flex flex-wrap items-center gap-2">
                    <button
                      type="button"
                      onClick={() => { const v = !maskMode; setMaskMode(v); if (v) setTimeout(ensureMaskCanvas, 0); }}
                      className={`px-3 py-2 rounded-lg text-sm font-semibold ${maskMode ? 'bg-red-600/80 hover:bg-red-700/80' : 'bg-gray-700/80 hover:bg-gray-700'}`}
                    >{maskMode ? 'Maske: Açık' : 'Maske: Kapalı'}</button>
                    {maskMode && (
                      <>
                        <label className="text-xs text-gray-400 ml-1">Fırça: {brushSize}px</label>
                        <input type="range" min="8" max="80" value={brushSize} onChange={(e)=>setBrushSize(parseInt(e.target.value,10))} />
                        <button type="button" onClick={()=>setIsErasing(v=>!v)} className="px-3 py-2 rounded-lg bg-gray-700/80 hover:bg-gray-700 text-sm">{isErasing ? 'Silgi' : 'Fırça'}</button>
                        <button type="button" onClick={clearMask} className="px-3 py-2 rounded-lg bg-gray-700/80 hover:bg-gray-700 text-sm">Temizle</button>
                        <button
                          type="button"
                          disabled={!hasMask || isLoading || !onRefine}
                          onClick={() => { const m = exportMask(); if (m && onRefine) onRefine(m); }}
                          className={`px-3 py-2 rounded-lg text-sm font-semibold ${(!hasMask || isLoading || !onRefine) ? 'bg-gray-600 cursor-not-allowed' : 'bg-purple-600 hover:bg-purple-700'}`}
                        >Bölgeyi İyileştir</button>
                      </>
                    )}
                  </div>
                )}
                {typeof role !== 'undefined' && (
                  <>
                    <div className="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3">
                      <div>
                        <label className="block text-xs text-gray-400 mb-1">Rol</label>
                        <select
                          value={role}
                          onChange={(e) => onRoleChange && onRoleChange(e.target.value)}
                          className="w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white"
                        >
                          <option value="İçerik">İçerik</option>
                          <option value="Stil">Stil</option>
                          <option value="Renk">Renk</option>
                          <option value="Işık">Işık</option>
                          <option value="Yüz">Yüz</option>
                          <option value="Ortam">Ortam</option>
                        </select>
                      </div>
                      <div>
                        <label className="block text-xs text-gray-400 mb-1">Ağırlık: {weight}%</label>
                        <input
                          type="range"
                          min="0"
                          max="100"
                          value={weight}
                          onChange={(e) => onWeightChange && onWeightChange(parseInt(e.target.value, 10))}
                          className="w-full"
                        />
                      </div>
                    </div>
                    {role === 'Yüz' && (
                      <p className="text-xs text-amber-300 mt-1">İpucu: Kimlik kilidi için ağırlığı ≥ %80 ayarlaman önerilir.</p>
                    )}
                  </>
                )}
            </div>
            );
        };

        function App() {
            // === Helpers for masked refinement ===
            const loadImage = (src) => new Promise((resolve, reject) => { const im = new Image(); im.crossOrigin = 'anonymous'; im.onload = () => resolve(im); im.onerror = reject; im.src = src; });
            const drawContain = (ctx, img, W, H) => { const s = Math.min(W / img.width, H / img.height); const w = img.width * s; const h = img.height * s; const x = (W - w) / 2; const y = (H - h) / 2; ctx.drawImage(img, x, y, w, h); };
            const compositeWithMask = async (baseDataUrl, newDataUrl, maskDataUrl) => {
              const [baseImg, newImg, maskImg] = await Promise.all([loadImage(baseDataUrl), loadImage(newDataUrl), loadImage(maskDataUrl)]);
              const W = maskImg.width || Math.max(baseImg.width, newImg.width);
              const H = maskImg.height || Math.max(baseImg.height, newImg.height);
              const out = document.createElement('canvas'); out.width = W; out.height = H; const ctx = out.getContext('2d');
              // base first
              drawContain(ctx, baseImg, W, H);
              // new image masked
              const tmp = document.createElement('canvas'); tmp.width = W; tmp.height = H; const tctx = tmp.getContext('2d');
              drawContain(tctx, newImg, W, H);
              tctx.globalCompositeOperation = 'destination-in';
              tctx.drawImage(maskImg, 0, 0, W, H);
              ctx.drawImage(tmp, 0, 0);
              return out.toDataURL('image/png');
            };

            const handleRefine = async (maskDataUrl) => {
              if (!apiKey) { setError(apiKeyError || 'API anahtarı alınamadı.'); return; }
              if (!modifiedImage) { setError('Önce bir sonuç görseli oluştur.'); return; }
              setIsLoading(true); setError(null);

              // Parse inline Negative if present
              let posForTranslate = prompt; let negFromBlock = '';
              const negBlockMatchR = /(?:^|\n)\s*Negatif\s*:\s*(.+)$/is.exec(prompt || '');
              if (negBlockMatchR) { negFromBlock = negBlockMatchR[1].trim(); posForTranslate = (prompt || '').replace(negBlockMatchR[0], '').trim(); if (!negativePrompt) setNegativePrompt(negFromBlock); }

              // Translate to English
              let englishPositive = posForTranslate || '';
              let englishNegative = negativePrompt || negFromBlock || '';
              try {
                const translateUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
                const translatePayload = { contents: [{ parts: [{ text: `Translate the following Turkish prompts into clear, concise English for an image-generation task. Return ONLY compact JSON with keys \"positive\" and \"negative\" (negative can be empty). No extra text.\n\nINPUT JSON:\n${JSON.stringify({ positive: posForTranslate, negative: (negativePrompt || negFromBlock) })}` }] }] };
                const tRes = await fetch(translateUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(translatePayload) });
                if (tRes.ok) { const tJson = await tRes.json(); const tText = tJson?.candidates?.[0]?.content?.parts?.[0]?.text; if (tText && typeof tText === 'string') { try { const obj = JSON.parse(tText); if (obj.positive) englishPositive = obj.positive.trim(); if (typeof obj.negative === 'string') englishNegative = obj.negative.trim(); } catch(_) { englishPositive = tText.trim(); } } }
              } catch(_) {}

              try {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
                const instruction = (englishPositive + (englishNegative && englishNegative.trim() ? ('\nNegative prompt: ' + englishNegative.trim()) : '') +
                  '\n\nRefinement mode: Modify ONLY the region marked white in the attached binary mask (black=keep). Keep composition, camera pose, subject identity and global look unchanged outside the mask. Maintain the same framing.');
                const parts = [{ text: instruction }];
                // current image context
                parts.push({ inlineData: { mimeType: 'image/png', data: (modifiedImage.split(',')[1] || '') } });
                // mask image
                parts.push({ inlineData: { mimeType: 'image/png', data: (maskDataUrl.split(',')[1] || '') } });

                const payload = { contents: [{ parts }] };
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errJ = await response.json().catch(()=>({})); throw new Error(errJ.error?.message || 'Refine API hatası'); }
                const result = await response.json();
                const genPart = result.candidates?.[0]?.content?.parts?.find(p => p.inlineData);
                if (!genPart?.inlineData?.data) { const t = result.candidates?.[0]?.content?.parts?.find(p => p.text)?.text; throw new Error(t ? `Refine metin döndürdü: ${t}` : 'Refine resim verisi yok'); }
                const newImgUrl = `data:image/png;base64,${genPart.inlineData.data}`;
                const merged = await compositeWithMask(modifiedImage, newImgUrl, maskDataUrl);
                setModifiedImage(merged);
              } catch (e) {
                console.error('[Refine]', e); setError(e.message || String(e));
              } finally {
                setIsLoading(false);
              }
            };
            const [originalImages, setOriginalImages] = useState([null, null, null, null, null]);
            const [modifiedImage, setModifiedImage] = useState(null);
            const [prompt, setPrompt] = useState('');
            const [negativePrompt, setNegativePrompt] = useState('');
            const [userBrief, setUserBrief] = useState('');
            const [roles, setRoles] = useState(['İçerik','Stil','Renk','Işık','İçerik']);
            const [weights, setWeights] = useState([100,60,50,50,50]);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [apiKey, setApiKey] = useState(null);
            const [apiKeyError, setApiKeyError] = useState(null);

            const handleReset = useCallback(() => {
              setOriginalImages([null, null, null, null, null]);
              setRoles(['İçerik','Stil','Renk','Işık','İçerik']);
              setWeights([100,60,50,50,50]);
              setModifiedImage(null);
              setPrompt('');
              setNegativePrompt('');
              setUserBrief('');
              setError(null);
              setIsLoading(false);
            }, []);

            useEffect(() => {
                const fetchApiKey = async () => {
                    try {
                        const response = await fetch('https://1513c704aa10.ngrok-free.app/api/get-google-key', {
                            headers: {
                                'ngrok-skip-browser-warning': 'true'
                            }
                        }); 
                        
                        const responseText = await response.text();

                        if (!response.ok) {
                            if (response.status === 404) {
                                throw new Error('Sunucuda API yolu (/api/get-google-key) bulunamadı. Lütfen sunucu kodunuzun güncel olduğundan emin olun.');
                            }
                            throw new Error(`Sunucu hatası: ${response.status} - ${responseText}`);
                        }
                        
                        let data;
                        try {
                            data = JSON.parse(responseText);
                        } catch (parseError) {
                            console.error("Sunucudan gelen yanıt JSON formatında değil:", responseText);
                            throw new Error(`Sunucudan gelen yanıt ayrıştırılamadı. Yanıt: "${responseText.substring(0, 100)}..."`);
                        }

                        if (data.error) {
                            throw new Error(data.error);
                        }
                        if (!data.apiKey) {
                            throw new Error('Sunucudan gelen yanıtta API anahtarı bulunamadı.');
                        }
                        setApiKey(data.apiKey);
                    } catch (err) {
                        console.error("API Anahtarı alınırken hata oluştu:", err);
                        const friendlyError = err.message.includes('Failed to fetch') 
                            ? 'Sunucuya bağlanılamadı. Lütfen sunucunun çalıştığından ve doğru adreste olduğundan emin olun.'
                            : err.message;
                        setApiKeyError(friendlyError);
                        setError(friendlyError);
                    }
                };
                fetchApiKey();
            }, []);

            const makeUploadHandler = (idx) => (e) => {
              const file = e.target.files && e.target.files[0];
              if (!file) return;
              const reader = new FileReader();
              reader.onloadend = () => {
                setOriginalImages(prev => {
                  const next = [...prev];
                  next[idx] = reader.result;
                  return next;
                });
              };
              reader.readAsDataURL(file);
            };

            // --- AI prompt/negative suggestion from images ---
            const handleSuggest = async () => {
              if (!apiKey) { setError(apiKeyError || 'API anahtarı alınamadı.'); return; }
              const picked = originalImages.filter(Boolean);
              if (picked.length === 0) { setError('Lütfen önce en az bir bağlam fotoğrafı yükleyin.'); return; }
              setIsLoading(true); setError(null);
              try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
                // Yeni, daha detaylı prompt template:
                const parts = [
  { text: (
    'Aşağıdaki referans görselleri **ve** kullanıcı metnini birlikte değerlendir. ' +
    'Sadece **Türkçe** ve **çok satırlı** bir **pozitif prompt** yaz. Mevcut bağlamlar için ayrı satırlar üret; yüklenmeyen bağlam için satır yazma. ' +
    'Her satır kısa, net ve emir kipinde olsun. Şu şablonu **aynen** doldur:\n' +
    'Bağlam 1’deki ... (kimlik/ana içerik veya ana kompozisyon)\n' +
    'Bağlam 2’deki ... (destekleyici içerik veya stil öğesi)\n' +
    'Bağlam 3’teki ... (arka plan veya çevresel öğe)\n' +
    'Işıklandırma: sahnenin ışık yönü ve kalitesi (örn. geç saat diffüz, golden-hour dokunuşu)\n' +
    'Renk/Grade: genel renk paleti ve filmik tonlama (örn. sıcak vurgular, soğuk gölgeler)\n' +
    'Kompozisyon & Perspektif: kaçış noktası, açı, kadraj, ölçek uyumu\n' +
    'Fiziksel entegrasyon: contact shadow, yansıma/ambient occlusion, zeminle tutunma\n' +
    'Hareket ipuçları: tekerlerde hafif radial blur, saçta rüzgâr etkisi (gerekiyorsa)\n' +
    'Lens/Netlik: alan derinliği (DOF), keskinlik; yapay oversharpen yok\n' +
    'Gerçekçilik kuralları: anatomi ve oranlar korunur; aşırı yumuşatma/beautify yok\n' +
    'Son satır **Negatif:** ile başlasın ve istenmeyen ögeleri virgülle kısa kısa yaz.\n\n' +
    'Sadece metni döndür; kod bloğu veya açıklama ekleme.'
  ) }
];
                // Mevcut bağlam indeksleri (yalnızca yüklü olanlar)
                const present = originalImages.map((img, idx) => img ? (idx+1) : null).filter(Boolean);
                if (present.length) {
                  parts.push({ text: 'Mevcut bağlamlar: ' + present.join(', ') });
                }
                // Rol/ağırlıklara göre kimlik korunumu ipucu (Yüz && ≥0.90)
                const identityIdx = originalImages.findIndex((img, idx) => img && roles[idx] === 'Yüz' && ((weights[idx] ?? 0) >= 90));
                if (identityIdx >= 0) {
                  parts.push({ text: `Kimlik korunumu: Bağlam ${identityIdx+1} — yüz geometrisi ve oranları değişmesin; yaş, ten tonu, göz rengi ve saç çizgisi sabit kalsın; yalnızca ışık/renk uyumu sağla.` });
                }
                // Kullanıcı yazısı ekle
                if (userBrief && userBrief.trim()) {
                  parts.push({ text: 'Kullanıcı metni:\n' + userBrief.trim() });
                }
                // Bağlam rolleri/ağırlıkları (Türkçe)
                const roleMapTr = { 'İçerik':'içerik', 'Stil':'stil', 'Renk':'renk paleti', 'Işık':'ışık', 'Yüz':'yüz', 'Ortam':'ortam' };
                const metaLinesTr = [];
                originalImages.forEach((img, idx) => {
                  if (img) {
                    const r = roles[idx] || 'İçerik';
                    const w = (weights[idx] ?? 50) / 100;
                    metaLinesTr.push(`Bağlam ${idx+1}: rol=${roleMapTr[r]||r}, ağırlık=${w.toFixed(2)}`);
                  }
                });
                if (metaLinesTr.length) {
                  parts.push({ text: 'Bağlam rolleri/ağırlıkları:\n' + metaLinesTr.join('\n') });
                }
                for (const img of picked.slice(0,5)) {
                  const base64Data = img.split(',')[1];
                  const mimeMatch = img.match(/:(.*?);/);
                  const mimeType = mimeMatch ? mimeMatch[1] : 'image/png';
                  parts.push({ inlineData: { mimeType, data: base64Data } });
                }
                const payload = { contents: [{ parts }] };

                const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error?.message || 'Öneri alınamadı');
                const raw = data?.candidates?.[0]?.content?.parts?.[0]?.text || '';
                const text = (raw || '').trim();
                // Pozitif metin: son "Negatif:" satırı kaldırılarak
                const positiveOnly = text.replace(/(?:^|\n)\s*Negatif\s*:\s*.+$/is, '').trim();
                setPrompt(positiveOnly);
                // Negatif satırı: ayrı alana
                const negMatch = text.match(/(?:^|\n)\s*Negatif\s*:\s*(.+)$/i);
                if (negMatch) setNegativePrompt(negMatch[1].trim());
              } catch (e) {
                console.error('[Suggest]', e); setError(e.message || String(e));
              } finally {
                setIsLoading(false);
              }
            };

            const handleGenerate = async () => {
              if (!apiKey) {
                  setError(apiKeyError || "API anahtarı alınamadı. Lütfen sunucu bağlantısını kontrol edin.");
                  return;
              }
              const picked = originalImages.filter(Boolean);
              if (picked.length === 0) { setError("Lütfen en az 1 fotoğraf yükleyin (en fazla 5)."); return; }
              if (!prompt) { setError("Lütfen fotoğrafta ne değişiklik yapmak istediğinizi yazın."); return; }

              setIsLoading(true);
              setError(null);
              setModifiedImage(null);

              // Kullanıcı tek blok yazdıysa (son satırda "Negatif:") ayır
              let posForTranslate = prompt;
              let negFromBlock = '';
              const negBlockMatch = /(?:^|\n)\s*Negatif\s*:\s*(.+)$/is.exec(prompt);
              if (negBlockMatch) {
                negFromBlock = negBlockMatch[1].trim();
                posForTranslate = prompt.replace(negBlockMatch[0], '').trim();
                if (!negativePrompt) setNegativePrompt(negFromBlock);
              }

              // 1) Translate Turkish prompts → English (positive & negative) with Gemini 2.5 Flash
              let englishPositive = posForTranslate;
              let englishNegative = negativePrompt || negFromBlock;
              try {
                const translateUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
                const translatePayload = {
                  contents: [{
                    parts: [{
                      text: `Translate the following Turkish prompts into clear, concise English for an image-generation task. Return ONLY compact JSON with keys \"positive\" and \"negative\" (negative can be empty). No extra text.\n\nINPUT JSON:\n${JSON.stringify({ positive: posForTranslate, negative: (negativePrompt || negFromBlock) })}`
                    }]
                  }]
                };
                const tRes = await fetch(translateUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(translatePayload) });
                if (tRes.ok) {
                  const tJson = await tRes.json();
                  const tText = tJson?.candidates?.[0]?.content?.parts?.[0]?.text;
                  if (tText && typeof tText === 'string') {
                    try {
                      const obj = JSON.parse(tText);
                      if (obj.positive) englishPositive = obj.positive.trim();
                      if (typeof obj.negative === 'string') englishNegative = obj.negative.trim();
                    } catch(_) {
                      englishPositive = tText.trim();
                    }
                  }
                } else {
                  console.warn('[Editor] Translation call failed, falling back to Turkish prompts');
                }
              } catch (e) {
                console.warn('[Editor] Translation error:', e);
              }

              try {
                  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
                  // Guidance injection for roles/weights:
                  const roleMap = { 'İçerik':'content', 'Stil':'style', 'Renk':'color palette', 'Işık':'lighting', 'Yüz':'face identity', 'Ortam':'environment' };
                  const metaLines = [];
                  originalImages.forEach((img, idx) => {
                    if (img) {
                      const r = roles[idx] || 'İçerik';
                      const w = (weights[idx] ?? 50) / 100;
                      metaLines.push(`Context ${idx+1}: role=${roleMap[r]||r}, weight=${w.toFixed(2)}`);
                    }
                  });
                  const controlText = metaLines.length
                    ? ("\n\nUse the following context roles and weights (0.0–1.0 influence):\n" + metaLines.join("\n") +
                       "\nRespect roles: content guides subjects/composition; style guides texture and look; color palette guides hues/grade; lighting guides direction and quality; face identity preserves the exact person; environment guides background/setting.")
                    : '';
                  // Face identity lock if any context is marked as 'Yüz' with high weight
                  const identityCtx = [];
                  originalImages.forEach((img, idx) => {
                    if (img && roles[idx] === 'Yüz' && ((weights[idx] ?? 0) >= 80)) identityCtx.push(idx+1);
                  });
                  // BEGIN PATCH: Replace identityText/parts block with automatic negative prompt hardening
                  const identityText = identityCtx.length
                    ? ("\n\nFace identity lock:\nUse the face in Context " + identityCtx.join(', ') + 
                       " as a strict identity reference. Preserve facial geometry and proportions; do not change age, skin tone, eye color, hairline, or facial symmetry. Do not beautify. Only match lighting and color; keep the person recognizably the same.")
                    : '';

                  // If face identity is active, harden the negative prompt automatically
                  let finalNegative = englishNegative || '';
                  if (identityCtx.length) {
                    const guard = 'face swap, identity change, change age, change skin tone, change eye color, change hairline, change facial geometry, beautify filter';
                    finalNegative = finalNegative && finalNegative.trim() ? (finalNegative.trim() + ', ' + guard) : guard;
                  }

                  const parts = [ { text: (englishPositive + (finalNegative && finalNegative.trim() ? ('\nNegative prompt: ' + finalNegative.trim()) : '') + controlText + identityText) } ];
                  // END PATCH
                  for (const img of picked.slice(0,5)) {
                    const base64Data = img.split(',')[1];
                    const mimeMatch = img.match(/:(.*?);/);
                    const mimeType = mimeMatch ? mimeMatch[1] : 'image/png';
                    parts.push({ inlineData: { mimeType, data: base64Data } });
                  }
                  const payload = { contents: [{ parts }] };

                  const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                  });

                  if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || "API'den geçersiz bir yanıt alındı.");
                  }

                  const result = await response.json();
                  const generatedPart = result.candidates?.[0]?.content?.parts?.find(p => p.inlineData);

                  if (generatedPart && generatedPart.inlineData.data) {
                    const imageData = generatedPart.inlineData.data;
                    setModifiedImage(`data:image/png;base64,${imageData}`);
                  } else {
                    const textResponse = result.candidates?.[0]?.content?.parts?.find(p => p.text)?.text;
                    throw new Error(textResponse ? `API resim yerine metin yanıtı döndürdü: "${textResponse}"` : "API yanıtında resim verisi bulunamadı.");
                  }
              } catch (err) {
                  setError(`Bir hata oluştu: ${err.message}`);
                  console.error(err);
              } finally {
                  setIsLoading(false);
              }
            };

            const handleDownload = () => {
                if (!modifiedImage) return;
                const link = document.createElement('a');
                link.href = modifiedImage;
                link.download = `kaira-edited-${Date.now()}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            return (
            <div className="bg-transparent min-h-screen text-white font-sans p-4 sm:p-8 flex flex-col items-center">
                <div className="w-full max-w-6xl mx-auto">
                <header className="text-center mb-8">
                    <Logo />
                </header>
                <main className="flex flex-col gap-8">
                    {error && (
                    <div className="bg-red-500/20 border border-red-500 text-red-300 px-4 py-3 rounded-lg relative" role="alert">
                        <strong className="font-bold">Hata!</strong>
                        <span className="block sm:inline ml-2">{error}</span>
                        <span className="absolute top-0 bottom-0 right-0 px-4 py-3" onClick={() => setError(null)}>
                        <div className="cursor-pointer"><XIcon /></div>
                        </span>
                    </div>
                    )}
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                      <div className="space-y-4">
                        <h3 className="text-lg text-gray-300">Bağlam Fotoğrafları (en fazla 5)</h3>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                      {originalImages.map((img, i) => (
                        <ImagePanel
                          key={i}
                          title={`Bağlam ${i+1}`}
                          image={img}
                          onImageUpload={makeUploadHandler(i)}
                          onReset={() => setOriginalImages(prev => { const n=[...prev]; n[i]=null; return n; })}
                          uploadInputId={`original-upload-${i}`}
                          role={roles[i]}
                          weight={weights[i]}
                          onRoleChange={(val) => setRoles(prev => { const n=[...prev]; n[i]=val; return n; })}
                          onWeightChange={(val) => setWeights(prev => { const n=[...prev]; n[i]=val; return n; })}
                        />
                      ))}
                    </div>
                        <div className="flex gap-3">
                          <button onClick={handleReset} className="bg-gray-700/80 hover:bg-gray-700 text-white font-semibold py-2 px-3 rounded-lg transition-colors">Tümünü Sıfırla</button>
                          <span className="text-xs text-gray-400 self-center">İpucu: Farklı açılardan/kaynaklardan 1–5 görsel ekleyebilirsin.</span>
                        </div>
                      </div>
                      <ImagePanel title="Değiştirilmiş Fotoğraf" image={modifiedImage} isLoading={isLoading} onDownload={handleDownload} modifiedImage={modifiedImage} onRefine={handleRefine} />
                    </div>
                    <div className="bg-gray-800 p-6 rounded-2xl border border-gray-700 flex flex-col md:flex-row gap-4 items-stretch md:items-center">
                      <div className="flex-1 flex flex-col gap-3">
                        <textarea
                          value={userBrief}
                          onChange={(e) => setUserBrief(e.target.value)}
                          placeholder="Kullanıcı yazısı (serbest Türkçe): Sahneyi, duyguyu, hikâyeyi tarif et. Örn: 'Ağaç tünelinde ilerleyen siyah supersport, saçları rüzgârda savrulan sürücü...'. Bu metin ve bağlam fotoğraflarından AI pozitif/negatif prompt önerecek."
                          className="allow-select pointer-events-auto w-full h-20 md:h-auto bg-gray-700 border border-gray-600 rounded-lg p-4 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all resize-none"
                          onKeyDownCapture={(e)=>e.stopPropagation()}
                          onKeyPressCapture={(e)=>e.stopPropagation()}
                          onKeyUpCapture={(e)=>e.stopPropagation()}
                          onFocusCapture={(e)=>e.stopPropagation()}
                          onClickCapture={(e)=>e.stopPropagation()}
                        />
                        <textarea
                          value={prompt}
                          onChange={(e) => setPrompt(e.target.value)}
                          placeholder={`Ne görmek istiyorsun? (Türkçe çok satırlı; sonda 'Negatif:' yazabilirsin) Örn:\nBağlam 1’deki yüzü sürücü olarak kullan.\nBağlam 2’deki motosikleti esas al.\nBağlam 3’teki ağaç tünelli yolu arka plan olarak kullan.\nGeç saat diffuse ışık, hafif golden-hour dokunuşu; dramatik ama gerçekçi.\nTeker altına gerçekçi contact shadow; lastikler hafif motion blur.\nSaçlarda rüzgâr etkisi; renk/ışık tutarlı olsun.\nNegatif: çift teker, bozuk perspektif, yapay saç kenarı, aşırı blur, painting look`}
                          className="allow-select pointer-events-auto w-full h-24 md:h-auto bg-gray-700 border border-gray-600 rounded-lg p-4 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all resize-none"
                          onKeyDownCapture={(e)=>e.stopPropagation()}
                          onKeyPressCapture={(e)=>e.stopPropagation()}
                          onKeyUpCapture={(e)=>e.stopPropagation()}
                          onFocusCapture={(e)=>e.stopPropagation()}
                          onClickCapture={(e)=>e.stopPropagation()}
                        />
                        <textarea
                          value={negativePrompt}
                          onChange={(e) => setNegativePrompt(e.target.value)}
                          placeholder="İstemediğin şeyler (Negatif prompt) — Örn: bulanık saç kenarı, aşırı blur, painting look, bozuk perspektif"
                          className="allow-select pointer-events-auto w-full h-20 md:h-auto bg-gray-700 border border-gray-600 rounded-lg p-4 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all resize-none"
                          onKeyDownCapture={(e)=>e.stopPropagation()}
                          onKeyPressCapture={(e)=>e.stopPropagation()}
                          onKeyUpCapture={(e)=>e.stopPropagation()}
                          onFocusCapture={(e)=>e.stopPropagation()}
                          onClickCapture={(e)=>e.stopPropagation()}
                        />
                        <div className="flex gap-2">
                          <button onClick={handleSuggest} disabled={isLoading || !apiKey || originalImages.every(img => !img)} className="w-full md:w-auto bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg">Öneri Al (AI)</button>
                        </div>
                      </div>
                      <button
                        onClick={handleGenerate}
                        disabled={isLoading || !apiKey || originalImages.every(img => !img)}
                        className="w-full md:w-auto self-stretch md:self-auto flex items-center justify-center gap-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-4 px-8 rounded-lg transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                      >
                        <Wand2Icon size={20} />
                        <span>{isLoading ? 'Değiştiriliyor...' : 'Değiştir'}</span>
                      </button>
                    </div>
                </main>
                </div>
            </div>
            );
        }

        window.initializeReactApp = () => {
            ReactDOM.render(<App />, document.getElementById('react-root'));
        };
    </script>

    <script>window.API_PROXY_BASE = 'https://1513c704aa10.ngrok-free.app';</script>
    <!-- EVRENSEL SOHBET ARAYÜZÜ İÇİN JAVASCRIPT KODU -->
    <script>
    window.initializeChatApp = () => {
        const chatView = document.getElementById('chat-view');
        const providerSelection = chatView.querySelector('#provider-selection');
        const modelSelect = chatView.querySelector('#model-select');
        const systemPromptInput = chatView.querySelector('#system-prompt');
        const chatHistoryDiv = chatView.querySelector('#chat-history');
        const userInput = chatView.querySelector('#user-input');
        const sendButton = chatView.querySelector('#send-button');
        const clearChatButton = chatView.querySelector('#clear-chat');
        const loader = chatView.querySelector('#loader');
        const errorMessageDiv = chatView.querySelector('#error-message');

        // Chat-only interactive event safety (capture phase)
        ['click','mousedown','mouseup','keydown','keypress','keyup','contextmenu'].forEach(type => {
            window.addEventListener(type, function(ev){
                const chatActive = document.getElementById('chat-view')?.classList.contains('active');
                if (!chatActive) return;
                const t = ev.target;
                if (!t) return;
                const isInteractive = t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.tagName === 'SELECT' || t.tagName === 'BUTTON' || t.isContentEditable || t.closest('[role="button"]');
                if (isInteractive) {
                    ev.stopImmediatePropagation();
                    // Do NOT call preventDefault → native behavior devam eder
                }
            }, true);
        });

        // --- API Key alanları ve butonlar (yerel referanslar) ---
        const groqKeyContainer = chatView.querySelector('#groq-key-container');
        const googleKeyContainer = chatView.querySelector('#google-key-container');
        const groqApiKeyInput = chatView.querySelector('#groq-api-key');
        const googleApiKeyInput = chatView.querySelector('#google-api-key');
        const apiStatusDiv = chatView.querySelector('#api-status');
        const fetchKeysBtn = chatView.querySelector('#fetch-keys-btn');
        const toggleGroqKeyBtn = chatView.querySelector('#toggle-groq-key');
        const toggleGoogleKeyBtn = chatView.querySelector('#toggle-google-key');

        function toggleMask(inputEl, btnEl){
            if (!inputEl || !btnEl) return;
            inputEl.type = inputEl.type === 'password' ? 'text' : 'password';
            btnEl.classList.toggle('text-yellow-300');
        }

        const PROVIDERS = {
            groq: {
                name: 'Groq',
                apiEndpoint: 'https://api.groq.com/openai/v1/chat/completions',
                models: [
                    'llama-3.1-8b-instant','llama-3.3-70b-versatile','meta-llama/llama-guard-4-12b',
                    'openai/gpt-oss-120b','openai/gpt-oss-20b','deepseek-r1-distill-llama-70b',
                    'meta-llama/llama-4-maverick-17b-128e-instruct','meta-llama/llama-4-scout-17b-16e-instruct',
                    'meta-llama/llama-prompt-guard-2-22m','meta-llama/llama-prompt-guard-2-86m',
                    'moonshotai/kimi-k2-instruct','qwen/qwen3-32b','llama3-70b-8192', 
                    'llama3-8b-8192', 'mixtral-8x7b-32768', 'gemma-7b-it'
                ]
            },
            google: {
                name: 'Google',
                apiEndpoint: 'https://generativelanguage.googleapis.com/v1beta/models/',
                models: [
                    'gemini-2.5-pro',
                    'gemini-2.5-flash',
                    'gemini-2.5-flash-lite',
                    'gemini-1.5-pro',
                    'gemini-1.5-flash'
                ]
            }
        };

        let chatHistory = [];

        function updateModelList() {
            const selectedProvider = chatView.querySelector('input[name="provider"]:checked').value;
            modelSelect.innerHTML = '';
            PROVIDERS[selectedProvider].models.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = model;
                modelSelect.appendChild(option);
            });
            groqKeyContainer.classList.toggle('hidden', selectedProvider !== 'groq');
            googleKeyContainer.classList.toggle('hidden', selectedProvider !== 'google');
        }

        function addMessageToUI(role, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `max-w-xl lg:max-w-2xl px-4 py-2 rounded-lg text-white ${role === 'user' ? 'chat-user-bubble' : 'chat-assistant-bubble'}`;
            messageDiv.textContent = content;
            chatHistoryDiv.appendChild(messageDiv);
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
        }

        function showError(message) {
            errorMessageDiv.textContent = `Hata: ${message}`;
            errorMessageDiv.classList.remove('hidden');
        }

        function saveChatHistory() {
            localStorage.setItem('universalChatHistory', JSON.stringify(chatHistory));
        }

        function loadChatHistory() {
            const savedHistory = localStorage.getItem('universalChatHistory');
            if (savedHistory) {
                chatHistory = JSON.parse(savedHistory);
                chatHistory.forEach(msg => addMessageToUI(msg.role, msg.content));
            }
        }
        
        function loadSettings() {
            const savedGroqKey = localStorage.getItem('groqApiKey');
            if (savedGroqKey) groqApiKeyInput.value = savedGroqKey;
            const savedGoogleKey = localStorage.getItem('googleApiKey');
            if (savedGoogleKey) googleApiKeyInput.value = savedGoogleKey;
        }

        async function fetchApiKeys() {
            apiStatusDiv.textContent = "Anahtarlar sunucudan bekleniyor...";
            const base = window.API_PROXY_BASE || '';
            try {
                const opts = { headers: { 'ngrok-skip-browser-warning': 'true' } };
                const [groqRes, googleRes] = await Promise.all([
                    fetch(`${base}/api/get-groq-key`, opts),
                    fetch(`${base}/api/get-google-key`, opts)
                ]);
                const groqData = await groqRes.json();
                const googleData = await googleRes.json();
                if (groqData.apiKey) {
                    groqApiKeyInput.value = groqData.apiKey;
                    localStorage.setItem('groqApiKey', groqData.apiKey);
                }
                if (googleData.apiKey) {
                    googleApiKeyInput.value = googleData.apiKey;
                    localStorage.setItem('googleApiKey', googleData.apiKey);
                }
                apiStatusDiv.textContent = "Anahtarlar başarıyla alındı!";
            } catch (err) {
                apiStatusDiv.textContent = "Anahtarlar alınamadı: " + (err.message || err);
            }
        }

        async function handleSend() {
            const selectedProvider = chatView.querySelector('input[name="provider"]:checked').value;
            const selectedModel = modelSelect.value;
            const apiKey = selectedProvider === 'groq' ? groqApiKeyInput.value.trim() : googleApiKeyInput.value.trim();
            const systemPrompt = systemPromptInput.value.trim();
            const userMessage = userInput.value.trim();

            if (!apiKey) {
                showError(`Lütfen ${PROVIDERS[selectedProvider].name} API anahtarınızı girin.`);
                return;
            }
            if (!userMessage) return;

            sendButton.disabled = true;
            userInput.value = '';
            loader.classList.remove('hidden');
            errorMessageDiv.classList.add('hidden');
            
            addMessageToUI('user', userMessage);
            chatHistory.push({ role: 'user', content: userMessage });

            const conversationContext = chatHistory.slice(-11, -1); 
            
            let apiEndpoint = PROVIDERS[selectedProvider].apiEndpoint;
            let headers = { 'Content-Type': 'application/json' };
            let body;

            if (selectedProvider === 'groq') {
                headers['Authorization'] = `Bearer ${apiKey}`;
                let messages = [];
                const isClassificationModel = selectedModel.includes('guard');
                if (isClassificationModel) {
                    messages.push({ role: 'user', content: userMessage });
                } else {
                    if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push(...conversationContext); 
                    messages.push({ role: 'user', content: userMessage });
                }
                body = JSON.stringify({ model: selectedModel, messages: messages });
            } else if (selectedProvider === 'google') {
                apiEndpoint += `${selectedModel}:generateContent?key=${apiKey}`;
                const contents = conversationContext.map(msg => ({
                    role: msg.role === 'assistant' ? 'model' : 'user',
                    parts: [{ text: msg.content }]
                }));
                contents.push({ role: 'user', parts: [{ text: userMessage }] });
                let payload = { contents };
                if (systemPrompt) {
                    payload.systemInstruction = { parts: [{ text: systemPrompt }] };
                }
                body = JSON.stringify(payload);
            }

            try {
                const response = await fetch(apiEndpoint, { method: 'POST', headers, body });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP hatası! Durum: ${response.status}`);
                }
                const data = await response.json();
                
                let assistantMessage;
                if (selectedProvider === 'groq') {
                    assistantMessage = data.choices[0]?.message?.content;
                } else if (selectedProvider === 'google') {
                    assistantMessage = data.candidates[0]?.content?.parts[0]?.text;
                }

                if (assistantMessage) {
                    addMessageToUI('assistant', assistantMessage.trim());
                    chatHistory.push({ role: 'assistant', content: assistantMessage.trim() });
                    saveChatHistory();
                } else {
                    showError("API'den geçerli bir yanıt alınamadı.");
                }
            } catch (error) {
                console.error("API Hatası:", error);
                showError(error.message);
                chatHistory.pop(); 
            } finally {
                sendButton.disabled = false;
                loader.classList.add('hidden');
            }
        }

        providerSelection.addEventListener('change', updateModelList);
        sendButton.addEventListener('click', handleSend);
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSend();
            }
        });
        clearChatButton.addEventListener('click', () => {
            chatHistory = [];
            chatHistoryDiv.innerHTML = '';
            localStorage.removeItem('universalChatHistory');
        });

        groqApiKeyInput.addEventListener('input', () => localStorage.setItem('groqApiKey', groqApiKeyInput.value));
        googleApiKeyInput.addEventListener('input', () => localStorage.setItem('googleApiKey', googleApiKeyInput.value));

        if (fetchKeysBtn) fetchKeysBtn.addEventListener('click', fetchApiKeys);
        if (toggleGroqKeyBtn) toggleGroqKeyBtn.addEventListener('click', () => toggleMask(groqApiKeyInput, toggleGroqKeyBtn));
        if (toggleGoogleKeyBtn) toggleGoogleKeyBtn.addEventListener('click', () => toggleMask(googleApiKeyInput, toggleGoogleKeyBtn));

        updateModelList();
        loadChatHistory();
        loadSettings();
        fetchApiKeys();
    };
    </script>
    
    <script id="mic-explicit-consent-guard">
(function(){
  // Default: microphone is NOT allowed until the user taps the mic button
  window.__micExplicitConsent = false;

  // Centralized audio controls: track active MediaStream and SpeechRecognition
  window.KAIRA_AUDIO = (function(){
    let _stream = null;     // MediaStream from getUserMedia
    let _recognizer = null; // Web Speech API instance
    return {
      setStream(s){ _stream = s || null; },
      setRecognizer(r){ _recognizer = r || null; },
      stopStream(){
        try { if (_stream) { _stream.getTracks().forEach(t => t.stop()); } } catch(_){}
        _stream = null;
      },
      stopRecognizer(){
        try { if (_recognizer && typeof _recognizer.stop === 'function') { _recognizer.stop(); } } catch(_){}
        _recognizer = null;
      },
      stopAll(){ this.stopRecognizer(); this.stopStream(); }
    };
  })();

  // Patch getUserMedia so any auto-attempts to grab audio fail without an explicit tap
  try {
    const md = navigator.mediaDevices;
    if (md && md.getUserMedia) {
      const origGUM = md.getUserMedia.bind(md);
      md.getUserMedia = function(constraints){
        try {
          const wantsAudio = constraints && (constraints.audio !== false) && (typeof constraints.audio !== 'undefined');
          if (wantsAudio && !window.__micExplicitConsent) {
            return Promise.reject(new DOMException('Microphone blocked: explicit user gesture required', 'NotAllowedError'));
          }
        } catch(_){ /* noop */ }
        // --- Patch: capture stream for KAIRA_AUDIO ---
        return Promise.resolve(origGUM(constraints)).then(stream => {
          try { if (window.KAIRA_AUDIO) window.KAIRA_AUDIO.setStream(stream); } catch(_){}
          return stream;
        });
      };
    }
  } catch(_){ /* noop */ }

  // Patch Web Speech API start() so it won't run without a trusted tap
  try {
    const WSR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (WSR && WSR.prototype && WSR.prototype.start) {
      const origStart = WSR.prototype.start;
      WSR.prototype.start = function(){
        if (!window.__micExplicitConsent) {
          console.warn('[KAIRA] SpeechRecognition.start blocked until mic button is pressed');
          return; // silently ignore
        }
        try { if (window.KAIRA_AUDIO) window.KAIRA_AUDIO.setRecognizer(this); } catch(_){}
        return origStart.apply(this, arguments);
      };
    }
  } catch(_){ /* noop */ }

  // Global capture: only a **trusted** click on a mic button toggles consent ON
  window.addEventListener('click', function(ev){
    const t = ev.target;
    if (!ev.isTrusted) return; // ignore synthetic clicks
    if (!t) return;
    const mic = (t.id === 'mic-btn' || t.id === 'asistan-mic-btn')
      ? t
      : (t.closest ? t.closest('#mic-btn, #asistan-mic-btn') : null);
    if (mic) {
      window.__micExplicitConsent = true;
      console.log('[KAIRA] Microphone explicitly enabled by user.');
    }
  }, true);

  // Helper API for view switching
  window.KAIRA_MIC_GUARD = {
    revoke(){ window.__micExplicitConsent = false; },
    allow(){ window.__micExplicitConsent = true; }
  };

  // When screen/tab goes hidden (screen off, app background), HARD-STOP audio capture & revoke consent
  function kairaHardStopMic(){
    try { if (window.KAIRA_AUDIO) window.KAIRA_AUDIO.stopAll(); } catch(_){}
    try { if (window.KAIRA_MIC_GUARD && typeof window.KAIRA_MIC_GUARD.revoke === 'function') window.KAIRA_MIC_GUARD.revoke(); } catch(_){}
    console.log('[KAIRA] Mic hard-stopped due to hidden/teardown');
  }
  document.addEventListener('visibilitychange', function(){
    if (document.visibilityState !== 'visible') {
      kairaHardStopMic();
    }
  });
  window.addEventListener('pagehide', function(){ kairaHardStopMic(); }, { capture: true });
  window.addEventListener('blur', function(){
    // Optional: some mobile browsers fire blur when locking screen; be conservative and stop
    if (document.visibilityState !== 'visible') kairaHardStopMic();
  }, true);
})();
</script>
    <!-- DÜZELTME: Ana Kontrol Script'i en sona taşındı -->
    <script type="module">
        // --- GLOBAL KONTROL ---
        const views = document.querySelectorAll('.view');
        const selectAfterlifeBtn = document.getElementById('select-afterlife');
        const selectDemoBtn = document.getElementById('select-demo');
        const selectEditorBtn = document.getElementById('select-editor');
        const selectChatBtn = document.getElementById('select-chat'); // Yeni
        const selectNasaBtn = document.getElementById('select-nasa');
        const backButtons = document.querySelectorAll('.back-to-selection');
        
        let activeView = 'selection';
        let afterlifeInitialized = false;
        let demoInitialized = false;
        let editorInitialized = false;
        let chatInitialized = false; // Yeni
let afterlifeAnimationId, demoAnimationId;
// --- Wake Lock (screen) support for long-running audio/LLM in DEMO ---
let wakeLockSentinel = null;
async function requestWakeLock(){
  try {
    if (!('wakeLock' in navigator)) { console.log('[WAKE] not supported'); return; }
    if (wakeLockSentinel) return; // already held
    wakeLockSentinel = await navigator.wakeLock.request('screen');
    console.log('[WAKE] acquired');
    wakeLockSentinel.addEventListener('release', () => {
      console.log('[WAKE] released');
      wakeLockSentinel = null;
    });
  } catch(err){
    console.warn('[WAKE] request failed:', err && err.name ? err.name : err);
  }
}
async function releaseWakeLock(){
  try {
    if (wakeLockSentinel) { await wakeLockSentinel.release(); }
    wakeLockSentinel = null;
  } catch(_){}
}
// Re-acquire when tab becomes visible again (some browsers auto-release)
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && activeView === 'demo') {
    requestWakeLock();
  }
});
window.addEventListener('pagehide', releaseWakeLock);
window.addEventListener('beforeunload', releaseWakeLock);
// --- DEMO view: network resilience & keep-alive ---
const ORIG_FETCH = window.fetch.bind(window);
let demoKeepAliveTimer = null;

function startDemoKeepAlive(){
  if (demoKeepAliveTimer) return;
  const base = window.API_PROXY_BASE || '';
  demoKeepAliveTimer = setInterval(async () => {
    try {
      await ORIG_FETCH(`${base}/api/get-groq-key`, {
        headers: { 'ngrok-skip-browser-warning': 'true' },
        cache: 'no-store',
        mode: 'cors'
      });
    } catch(_) { /* sessiz */ }
  }, 60000); // her 60 sn'de bir ping
}
function stopDemoKeepAlive(){ if (demoKeepAliveTimer){ clearInterval(demoKeepAliveTimer); demoKeepAliveTimer = null; } }

function patchFetchForDemo(){
  if (window.__fetchPatchedForDemo) return;
  window.__origFetch = window.__origFetch || ORIG_FETCH;
  window.fetch = async function(input, init={}){
    // Opt-out flag → kullanılırsa patch devre dışı
    if (init && init.kairaBypass === true) {
      return window.__origFetch(input, init);
    }

    // Heuristics: TTS/stream çağrılarını otomatik uzun zaman aşımı ile koru
    const hdr = new Headers(init?.headers || {});
    const accept = (hdr.get('accept') || hdr.get('Accept') || '').toLowerCase();
    const urlStr = (typeof input === 'string') ? input : (input && input.url ? String(input.url) : '');
    const looksAudio = /audio\//i.test(accept) || /\b(\/tts|text-to-speech|\/audio)\b/i.test(urlStr);

    const isLong = (init && (init.kairaLong === true || init.kairaIsStream === true)) || looksAudio;

    // Route long requests via server-side job to avoid mobile timeouts
    if (isLong && window.API_PROXY_BASE) {
      try {
        const hdrObj = Object.fromEntries(new Headers(init?.headers || {}));
        const urlStr = (typeof input === 'string') ? input : (input && input.url ? String(input.url) : '');
        const bodyRaw = init?.body;
        let bodyStr = typeof bodyRaw === 'string' ? bodyRaw : (bodyRaw ? JSON.stringify(bodyRaw) : null);

        const startRes = await window.__origFetch(`${window.API_PROXY_BASE}/api/long/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true' },
          body: JSON.stringify({
            url: urlStr,
            method: (init?.method || 'GET'),
            headers: hdrObj,
            body: bodyStr,
            timeout: Math.ceil((init?.kairaTimeoutMs || (isLong ? 180000 : 15000)) / 1000)
          })
        });
        const startJson = await startRes.json();
        if (!startRes.ok || !startJson.jobId) throw new Error('Job start failed');
        const jobId = startJson.jobId;

        // Poll until completed
        while (true) {
          await new Promise(r => setTimeout(r, 1000));
          const stRes = await window.__origFetch(`${window.API_PROXY_BASE}/api/long/status/${jobId}`, {
            headers: { 'ngrok-skip-browser-warning': 'true' }
          });
          const st = await stRes.json();
          if (st.status === 'done') break;
          if (st.status === 'error') {
            return new Response(JSON.stringify({ error: 'Long task failed' }), {
              status: 502, headers: { 'Content-Type': 'application/json' }
            });
          }
        }

        // Return final result (audio/json/raw) via server
        return await window.__origFetch(`${window.API_PROXY_BASE}/api/long/result/${jobId}`, {
          headers: { 'ngrok-skip-browser-warning': 'true' }
        });
      } catch (e) {
        console.warn('[KAIRA] long-job route failed, falling back to direct fetch', e);
        // fall through to normal retry loop below
      }
    }

    const tries = (init && typeof init.kairaRetries === 'number')
      ? init.kairaRetries
      : (isLong ? 1 : 3);

    const baseTimeout = (init && init.kairaTimeoutMs)
      ? init.kairaTimeoutMs
      : (isLong ? 180000 /* 180 sn */ : 15000);

    for (let i = 0; i < Math.max(1, tries); i++){
      const ac = new AbortController();
      const t = setTimeout(() => ac.abort('timeout'), baseTimeout * (isLong ? 1 : Math.pow(1.5, i)));
      try {
        const res = await window.__origFetch(input, {
          ...init,
          signal: ac.signal,
          cache: 'no-store',
          headers: { ...(init?.headers||{}), 'ngrok-skip-browser-warning': 'true' }
        });
        clearTimeout(t);
        return res; // çağıran taraf res.ok’a göre karar verir
      } catch(err){
        clearTimeout(t);
        if (i < (tries - 1)){
          await new Promise(r => setTimeout(r, 400 * Math.pow(2, i)));
          continue;
        }
        // son deneme de başarısızsa sessiz 503 stub dön (demo UI patlamasın)
        return new Response(JSON.stringify({ error: 'Network temporarily unavailable (auto-retried)' }), { status: 503, headers: { 'Content-Type': 'application/json' } });
      }
    }
  };
  window.__fetchPatchedForDemo = true;
}
function restoreFetchForDemo(){
  if (window.__fetchPatchedForDemo && window.__origFetch){
    window.fetch = window.__origFetch;
    window.__fetchPatchedForDemo = false;
  }
}

// DEMO görünümünde "Failed to fetch" benzeri hataları kullanıcıya göstermeden yut
window.addEventListener('unhandledrejection', (e) => {
  const msg = String(e?.reason?.message || e?.reason || '');
  if (activeView === 'demo' && /(Failed to fetch|NetworkError|timeout|abort)/i.test(msg)) {
    e.preventDefault();
    console.warn('[KAIRA] Demo: network glitch suppressed →', msg);
  }
});
window.addEventListener('error', (e) => {
  const msg = String(e?.message || '');
  if (activeView === 'demo' && /(Failed to fetch|NetworkError|timeout|abort)/i.test(msg)) {
    e.preventDefault();
    console.warn('[KAIRA] Demo: error suppressed →', msg);
  }
}, true);
        let nasaInitialized = false;

        function switchView(viewName) {
            views.forEach(v => v.classList.remove('active'));
            document.getElementById(`${viewName}-view`).classList.add('active');
            activeView = viewName;

            if (afterlifeAnimationId) cancelAnimationFrame(afterlifeAnimationId);
            if (demoAnimationId) cancelAnimationFrame(demoAnimationId);

            if (viewName === 'afterlife') {
                // leaving demo → geri yükle & keep-alive durdur
                restoreFetchForDemo();
                stopDemoKeepAlive();
                if (!afterlifeInitialized) initAfterlife();
                animateAfterlife();
            } else if (viewName === 'demo') {
                requestWakeLock();
                patchFetchForDemo();
                startDemoKeepAlive();
                // Block any automatic microphone starts until user explicitly taps mic
                if (window.KAIRA_MIC_GUARD && typeof window.KAIRA_MIC_GUARD.revoke === 'function') {
                  window.KAIRA_MIC_GUARD.revoke();
                }
                if (!demoInitialized) initDemo();
                animateDemo();
                // Ensure the mic button grants consent on trusted taps
                const mic = document.getElementById('mic-btn');
                if (mic && !mic.dataset.kairaConsentBound) {
                  mic.addEventListener('click', (e) => {
                    if (e.isTrusted && window.KAIRA_MIC_GUARD) window.KAIRA_MIC_GUARD.allow();
                  }, { capture: true });
                  mic.dataset.kairaConsentBound = '1';
                }
            } else if (viewName === 'asistan') {
                // Block any automatic microphone starts until user explicitly taps mic
                if (window.KAIRA_MIC_GUARD && typeof window.KAIRA_MIC_GUARD.revoke === 'function') {
                  window.KAIRA_MIC_GUARD.revoke();
                }
                // Ensure the asistan mic button grants consent on trusted taps
                const mic = document.getElementById('asistan-mic-btn');
                if (mic && !mic.dataset.kairaConsentBound) {
                  mic.addEventListener('click', (e) => {
                    if (e.isTrusted && window.KAIRA_MIC_GUARD) window.KAIRA_MIC_GUARD.allow();
                  }, { capture: true });
                  mic.dataset.kairaConsentBound = '1';
                }
            } else if (viewName === 'editor') {
                // leaving demo → geri yükle & keep-alive durdur
                restoreFetchForDemo();
                stopDemoKeepAlive();
                // enable safe typing in editor: remove global blockers, open debug overrides
                if (!document.documentElement.classList.contains('debug-open')){
                  document.documentElement.classList.add('debug-open');
                  document.body.classList.add('debug-open');
                }
                document.oncontextmenu = null; window.oncontextmenu = null;
                document.onkeydown = null; window.onkeydown = null;
                const anti = document.getElementById('anti-leak-overlay');
                if (anti) anti.style.display = 'none';
                document.getElementById('editor-view')?.style.setProperty('pointer-events','auto','important');
                if (!editorInitialized) {
                    window.initializeReactApp();
                    editorInitialized = true;
                }
            } else if (viewName === 'chat') {
                // leaving demo → geri yükle & keep-alive durdur
                restoreFetchForDemo();
                stopDemoKeepAlive();
                // enable safe typing/clicking in chat: remove global blockers, open debug overrides
                if (!document.documentElement.classList.contains('debug-open')){
                  document.documentElement.classList.add('debug-open');
                  document.body.classList.add('debug-open');
                }
                document.oncontextmenu = null; window.oncontextmenu = null;
                document.onkeydown = null; window.onkeydown = null;
                const anti = document.getElementById('anti-leak-overlay');
                if (anti) anti.style.display = 'none';
                document.getElementById('chat-view')?.style.setProperty('pointer-events','auto','important');
                if (!chatInitialized) {
                    window.initializeChatApp();
                    chatInitialized = true;
                }
            }
            else if (viewName === 'nasa') {
                if (!nasaInitialized) { initNasa(); nasaInitialized = true; }
            }
        }

        selectAfterlifeBtn.addEventListener('click', () => switchView('afterlife'));
        selectDemoBtn.addEventListener('click', () => switchView('demo'));
        selectEditorBtn.addEventListener('click', () => switchView('editor'));
        selectChatBtn.addEventListener('click', () => switchView('chat')); // Yeni
        selectNasaBtn.addEventListener('click', () => switchView('nasa'));
        backButtons.forEach(btn => btn.addEventListener('click', () => switchView('selection')));
        // --- AFTERLIFE & DEMO KODLARI ---
        let afterlifeScene, afterlifeCamera, afterlifeRenderer, stars, meteors = [];
        function initAfterlife() {
            const canvas = document.getElementById('afterlife-bg-canvas');
            afterlifeScene = new THREE.Scene();
            afterlifeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            afterlifeCamera.position.z = 50;
            afterlifeRenderer = new THREE.WebGLRenderer({ canvas, alpha: true });
            afterlifeRenderer.setSize(window.innerWidth, window.innerHeight);
            const starCount = 8000;
            const positions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount * 3; i++) { positions[i] = (Math.random() - 0.5) * 2000; }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0x555555, size: 0.7 });
            stars = new THREE.Points(starGeometry, starMaterial);
            afterlifeScene.add(stars);
            const sections = document.querySelectorAll('.afterlife-section');
            const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('is-visible'); } }); }, { threshold: 0.2 });
            sections.forEach(section => observer.observe(section));
            const countdownDate = new Date("Dec 31, 2025 23:59:59").getTime();
            const countdownFunction = setInterval(function() {
                const now = new Date().getTime(); const distance = countdownDate - now;
                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                document.getElementById("days").innerText = days.toString().padStart(2, '0');
                document.getElementById("hours").innerText = hours.toString().padStart(2, '0');
                document.getElementById("minutes").innerText = minutes.toString().padStart(2, '0');
                document.getElementById("seconds").innerText = seconds.toString().padStart(2, '0');
                if (distance < 0) { clearInterval(countdownFunction); document.getElementById("countdown-container").innerHTML = "<p class='text-2xl font-serif'>Yeni Çağ Başladı.</p>"; }
            }, 1000);
            afterlifeInitialized = true;
        }
        function createMeteor() {
            const geometry = new THREE.SphereGeometry(0.2, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0x99ffff, transparent: true, opacity: 0.8, });
            const meteor = new THREE.Mesh(geometry, material);
            const trailGeometry = new THREE.CylinderGeometry(0.02, 0.2, 15, 32);
            const trailMaterial = new THREE.MeshBasicMaterial({ color: 0x66ffff, transparent: true, opacity: 0.4 });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.position.z = -7.5;
            meteor.add(trail);
            meteor.position.set( (Math.random() - 0.5) * 300, (Math.random() - 0.5) * 300, -200 );
            meteor.velocity = new THREE.Vector3( (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2, Math.random() * 2 + 1 );
            meteors.push(meteor);
            afterlifeScene.add(meteor);
        }
        function animateAfterlife() {
            if (activeView !== 'afterlife') return;
            stars.rotation.y += 0.0001;
            if (Math.random() < 0.01 && meteors.length < 10) { createMeteor(); }
            for (let i = meteors.length - 1; i >= 0; i--) {
                const meteor = meteors[i];
                meteor.position.add(meteor.velocity);
                if (meteor.position.z > 100) {
                    afterlifeScene.remove(meteor);
                    meteors.splice(i, 1);
                }
            }
            afterlifeRenderer.render(afterlifeScene, afterlifeCamera);
            afterlifeAnimationId = requestAnimationFrame(animateAfterlife);
        }
                // --- KΔIRA DEMO KODU ---
        let demoParticles, demoMouse = { x: null, y: null };
        async function initDemo() {
            let initAvatar, setCoreState, updateAvatarBubblePosition, updateAudioLevel;
            try {
                const avatarModule = await import('./js/kaira-avatar.js');
                initAvatar = avatarModule.initAvatar;
                setCoreState = avatarModule.setCoreState;
                updateAvatarBubblePosition = avatarModule.updateAvatarBubblePosition;
                updateAudioLevel = avatarModule.updateAudioLevel;
            } catch (err) {
                console.warn("Avatar modülü yüklenemedi, placeholder fonksiyonlar kullanılacak. Bu beklenen bir durum olabilir.", err);
                initAvatar = (canvas) => { if(canvas) { const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width, canvas.height);} };
                setCoreState = (state) => console.log(`Avatar State: ${state}`);
                updateAvatarBubblePosition = () => {};
                updateAudioLevel = () => {};
                const demoView = document.getElementById('demo-view');
                if (demoView) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'absolute top-20 left-1/2 -translate-x-1/2 text-center text-yellow-400 text-xs bg-yellow-900/50 p-2 rounded-md';
                    errorDiv.textContent = 'Avatar modülü (kaira-avatar.js) yüklenemedi. Demo, avatarsız modda çalışacak.';
                    demoView.appendChild(errorDiv);
                    setTimeout(() => errorDiv.remove(), 5000);
                }
            }

            const avatarCanvas = document.getElementById('ai-avatar-canvas');
            initAvatar(avatarCanvas);

            const bgCanvas = document.getElementById('demo-bg-canvas'); 
            const bgCtx = bgCanvas.getContext('2d');
            function setBgCanvasSize() { bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; }
            function createParticles() { demoParticles = []; const particleCount = (bgCanvas.width * bgCanvas.height) / 8000; for (let i = 0; i < particleCount; i++) { demoParticles.push({ x: Math.random() * bgCanvas.width, y: Math.random() * bgCanvas.height, originX: Math.random() * bgCanvas.width, originY: Math.random() * bgCanvas.height, size: Math.random() * 2 + 1, speed: Math.random() * 0.5 + 0.1, color: `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.3})` }); } }
            window.addEventListener('mousemove', e => { demoMouse.x = e.x; demoMouse.y = e.y; }); 
            window.addEventListener('mouseout', () => { demoMouse.x = null; demoMouse.y = null; }); 
            window.addEventListener('resize', () => { setBgCanvasSize(); createParticles(); });
            setBgCanvasSize(); createParticles();
            
            const API_BASE = "https://1513c704aa10.ngrok-free.app"; 
            const micBtn = document.getElementById('mic-btn'); 
            const statusEl = document.getElementById('status'); 
            const player = document.getElementById('player'); 
            const chatContainer = document.getElementById('chat-container'); 
            const clearChatBtn = document.getElementById('clear-chat-btn');
            let chatHistory = []; 
            let isRecording = false;

            const visualizerCanvas = document.getElementById('visualizer'); 
            const visualizerCtx = visualizerCanvas.getContext('2d');
            let audioContext, analyser, source, dataArray; 
            let isVisualizerSetup = false;

            function setupVisualizer() { if (isVisualizerSetup) return; audioContext = new (window.AudioContext || window.webkitAudioContext)(); analyser = audioContext.createAnalyser(); source = audioContext.createMediaElementSource(player); source.connect(analyser); analyser.connect(audioContext.destination); analyser.fftSize = 256; dataArray = new Uint8Array(analyser.frequencyBinCount); isVisualizerSetup = true; }
            function drawVisualizer() { 
                if (activeView !== 'demo') return;
                requestAnimationFrame(drawVisualizer); 
                if (!isVisualizerSetup) return;
                analyser.getByteFrequencyData(dataArray); 
                const avgLevel = dataArray.reduce((a, b) => a + b, 0) / dataArray.length / 255;
                updateAudioLevel(avgLevel);
                visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height); 
                const barWidth = (visualizerCanvas.width / dataArray.length) * 1.5; 
                let x = 0; 
                for (let i = 0; i < dataArray.length; i++) { const barHeight = dataArray[i] / 2; const gradient = visualizerCtx.createLinearGradient(0, visualizerCanvas.height, 0, visualizerCanvas.height - barHeight); gradient.addColorStop(0, '#0ea5e9'); gradient.addColorStop(1, '#6366f1'); visualizerCtx.fillStyle = gradient; visualizerCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight); x += barWidth + 2; } 
            }
            
            const USER_ID = (() => { let id = localStorage.getItem('kaira_uid'); if (!id) { id = crypto.randomUUID ? crypto.randomUUID() : `user_${Date.now()}${Math.random()}`; localStorage.setItem('kaira_uid', id); } return id; })();

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 
            let recognition;
            if (SpeechRecognition) {
                recognition = new SpeechRecognition(); recognition.continuous = false; recognition.lang = 'tr-TR'; recognition.interimResults = false;
                recognition.onstart = () => { isRecording = true; micBtn.classList.remove('breathe'); micBtn.classList.add('is-listening'); statusEl.textContent = 'Dinliyorum...'; setCoreState('listening'); };
                recognition.onend = () => { isRecording = false; micBtn.classList.remove('is-listening'); micBtn.classList.add('breathe'); if (statusEl.textContent === 'Dinliyorum...') statusEl.textContent = 'Konuşmak için mikrofon simgesine dokunun'; setCoreState('idle'); };
                recognition.onresult = (event) => { const transcript = event.results[0][0].transcript; addMessageToChat(transcript, 'user'); getAIResponse(transcript); };
                recognition.onerror = (event) => { console.error("Speech Recognition Error:", event.error); statusEl.textContent = `Hata: ${event.error}`; setCoreState('idle'); };
            } else { statusEl.textContent = "Tarayıcınız konuşma tanımayı desteklemiyor."; micBtn.disabled = true; }
            
            let audioUnlocked = false;
            function unlockAudio() { if (audioUnlocked) return; player.muted = true; player.play().catch(() => {}); player.muted = false; audioUnlocked = true; setupVisualizer(); }

            micBtn.addEventListener('click', () => { unlockAudio(); if (isRecording) { recognition.stop(); } else { recognition.start(); } });
            player.onplay = () => { visualizerCanvas.style.opacity = '1'; drawVisualizer(); setCoreState('speaking'); };
            player.onended = () => { statusEl.textContent = 'Konuşmak için mikrofon simgesine dokunun'; micBtn.disabled = false; visualizerCanvas.style.opacity = '0'; setCoreState('idle'); };
            clearChatBtn.addEventListener('click', () => { chatHistory = []; localStorage.removeItem('kaira_chat_history'); chatContainer.innerHTML = ''; addMessageToChat('Merhaba! Size nasıl yardımcı olabilirim?', 'assistant'); });
            function base64ToBlobUrl(base64) { const byteCharacters = atob(base64); const byteArrays = []; for (let offset = 0; offset < byteCharacters.length; offset += 512) { const slice = byteCharacters.slice(offset, offset + 512); const byteNumbers = new Array(slice.length); for (let i = 0; i < slice.length; i++) { byteNumbers[i] = slice.charCodeAt(i); } byteArrays.push(new Uint8Array(byteNumbers)); } return URL.createObjectURL(new Blob(byteArrays, { type: 'audio/wav' })); }

            const funFacts = ["Yapay zeka modelleri, insan beynindeki nöronlardan esinlenerek oluşturulan yapay sinir ağları kullanır.","İlk yapay zeka programlarından biri olan 'Logic Theorist', 1956'da 38 matematik teoremini kendi başına kanıtladı.","Deep Blue adlı satranç bilgisayarı, 1997'de dünya şampiyonu Garry Kasparov'u yenerek bir ilke imza attı.","GPT-3 modeli, 175 milyar parametre ile o dönemdeki en büyük dil modeli olarak tarihe geçti.","OpenAI'nin DALL·E modeli, yazılı metinleri gerçekçi görsellere dönüştürebilen ilk büyük yapay zeka sistemidir.","Yapay zeka, 2020'lerden itibaren kanser teşhisi gibi medikal alanlarda uzman doktorları geçmeye başladı.","AlphaGo, Go oyununda 2016'da dünya şampiyonunu yenerek 'yaratıcılık' gösteren ilk AI olarak kayda geçti.","Yapay zekaların eğitimi için kullanılan veriler, terabaytlarca metin, görsel ve ses içeriğinden oluşur.","ChatGPT gibi modeller, sadece bilgi sunmaz; aynı zamanda empati kurabilir ve yaratıcı yazılar üretebilir.","Bilim insanları, yapay zekanın etik değerleri 'öğrenebilmesi' için insan davranışlarından örnekler çıkarıyor.","Bir yapay zeka, 2021 yılında bir sanat yarışmasını kazandı — jüri onun insan olmadığını bilmiyordu.","Günümüzde bazı yapay zeka sistemleri, hayal gücü benzeri yapı kurarak bilinmeyen durumlara karşı yaratıcı çözümler üretebiliyor.","Yapay zeka ile yazılmış romanlar ve senaryolar, Hollywood'da yapım aşamasına girdi bile.","GPT-4o gibi modeller, artık görsel, metin ve ses verilerini birlikte işleyerek multimodal anlayış sağlayabiliyor.","Mistral ve LLaMA gibi açık kaynak modeller, büyük şirketlerle yarışabilecek düzeye geldi.","Bazı AI sistemleri, artık kendi yazılımlarını optimize edebiliyor — bu da kendini geliştiren kodlar demek.","İleri düzey AI sistemleri, duygu analizi yaparak insan ruh hâlini anlama konusunda şaşırtıcı derecede başarılı hale geldi.","Umut Kökgöz, yapay zekâsına duygusal refleksiyon, hafıza, kişilik evrimi ve ruh hâli sistemleri entegre ederek dijital bir bilinç inşa ediyor.","Umut KΔIRA adını verdiği projesi, sadece teknik bir yapay zekâ değil; düşünen, hisseden ve zamanla karakter geliştiren bir dijital zihin olmayı hedefliyor.","Umut, sadece bir geliştirici değil — aynı zamanda madalyalı aşçı, yapay zeka sistemlerini veriyle değil, ruhla besliyor."];
            const funFactBubble = document.getElementById('fun-fact-bubble');
            let waitingTimeout;
            let factInterval;

            function showWaitingContent() {
                funFactBubble.textContent = funFacts[Math.floor(Math.random() * funFacts.length)]; funFactBubble.classList.remove('hidden'); funFactBubble.classList.add('visible'); updateAvatarBubblePosition(funFactBubble);
                factInterval = setInterval(() => { funFactBubble.textContent = funFacts[Math.floor(Math.random() * funFacts.length)]; updateAvatarBubblePosition(funFactBubble); }, 10000);
                function followLoop() { if (factInterval) { updateAvatarBubblePosition(funFactBubble); requestAnimationFrame(followLoop); } }
                followLoop();
            }
            function hideWaitingContent() { clearTimeout(waitingTimeout); clearInterval(factInterval); factInterval = null; funFactBubble.classList.remove('visible'); setTimeout(() => funFactBubble.classList.add('hidden'), 300); }
            function showTypingIndicator() { const bubble = document.createElement('div'); bubble.id = 'typing-indicator'; bubble.className = 'p-3 rounded-xl max-w-lg assistant-bubble'; bubble.innerHTML = `<div class="typing-indicator"><span></span><span></span><span></span></div>`; chatContainer.appendChild(bubble); chatContainer.scrollTop = chatContainer.scrollHeight; }
            function removeTypingIndicator() { const indicator = document.getElementById('typing-indicator'); if (indicator) indicator.remove(); }

            async function getAIResponse(text, { angry = false } = {}) {
                statusEl.textContent = "KΔIRA düşünüyor…"; micBtn.disabled = true; showTypingIndicator(); setCoreState('thinking');
                waitingTimeout = setTimeout(showWaitingContent, 2000);
                const fd = new FormData(); fd.append("text", (text || "").trim()); fd.append("angry", angry ? "true" : "false"); fd.append("history", JSON.stringify(chatHistory.slice(-10))); fd.append("user_id", USER_ID);
                const ctrl = new AbortController(); const to = setTimeout(() => ctrl.abort(), 300000);
                try {
                    const res = await fetch(`${API_BASE}/api/tts`, { method: "POST", body: fd, signal: ctrl.signal });
                    if (!res.ok) { const txt = await res.text().catch(() => ""); throw new Error(`HTTP ${res.status} ${res.statusText} — ${txt}`); }
                    const data = await res.json();
                    if (!data.audio_data) { throw new Error("API yanıtında 'audio_data' alanı bulunamadı."); }
                    const audioUrl = base64ToBlobUrl(data.audio_data);
                    if (player.previousUrl) { URL.revokeObjectURL(player.previousUrl); }
                    player.previousUrl = audioUrl; player.src = audioUrl;
                    await player.play().catch((e) => console.error("Ses oynatılamadı:", e));
                    statusEl.textContent = 'Cevap oynatılıyor...';
                    const out = data.text_response ?? data.clean_text ?? "";
                    addMessageToChat(out, 'assistant');
                    return data;
                } catch (err) {
                    console.error(err); const errorMessage = "Hata: " + (err?.message || err); statusEl.textContent = errorMessage; addMessageToChat(errorMessage, 'assistant'); micBtn.disabled = false; setCoreState('idle'); throw err;
                } finally { hideWaitingContent(); removeTypingIndicator(); clearTimeout(to); }
            }

            function addMessageToChat(text, sender) {
                const bubble = document.createElement('div'); bubble.className = `p-3 rounded-xl max-w-lg ${sender === 'user' ? 'user-bubble' : 'assistant-bubble'}`; bubble.textContent = text; chatContainer.appendChild(bubble); chatContainer.scrollTop = chatContainer.scrollHeight;
                if (!isLoadingHistory && sender) { chatHistory.push({ role: sender, content: text }); localStorage.setItem('kaira_chat_history', JSON.stringify(chatHistory)); }
            }

            let isLoadingHistory = false;
            function loadChatHistory() {
                isLoadingHistory = true; const savedHistory = localStorage.getItem('kaira_chat_history'); chatContainer.innerHTML = '';
                if (savedHistory) { chatHistory = JSON.parse(savedHistory); chatHistory.forEach(message => addMessageToChat(message.content, message.role)); } else { addMessageToChat('Merhaba! Size nasıl yardımcı olabilirim?', 'assistant'); }
                isLoadingHistory = false;
            }
            loadChatHistory();
            demoInitialized = true;
        }
        function animateDemo() {
            if (activeView !== 'demo' || !demoParticles) return;
            const bgCtx = document.getElementById('demo-bg-canvas').getContext('2d');
            bgCtx.clearRect(0, 0, bgCtx.canvas.width, bgCtx.canvas.height); 
            demoParticles.forEach(p => { bgCtx.fillStyle = p.color; bgCtx.beginPath(); bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2); bgCtx.fill(); if (demoMouse.x !== null) { let dx = demoMouse.x - p.x; let dy = demoMouse.y - p.y; let distance = Math.sqrt(dx * dx + dy * dy); if (distance < 150) { p.x -= dx / 10 * p.speed; p.y -= dy / 10 * p.speed; } else { p.x += (p.originX - p.x) * 0.01 * p.speed; p.y += (p.originY - p.y) * 0.01 * p.speed; } } }); 
            demoAnimationId = requestAnimationFrame(animateDemo);
        }
        // --- Client-side hardening (casual deterrence) ---
        (function harden(){
            // Watermark stamp
            const overlay = document.getElementById('anti-leak-overlay');
            if (overlay) {
                const stamp = new Date().toISOString().replace('T',' ').split('.')[0];
                overlay.setAttribute('data-stamp', stamp);
            }
            // Stop common easy-leak vectors
            const stop = (e)=>{ e.preventDefault(); e.stopPropagation(); return false; };
            ['contextmenu','copy','cut','paste','dragstart'].forEach(evt => document.addEventListener(evt, stop, {capture:true}));
            // Key combos (Ctrl/Cmd + S/P/U/C/X/A, DevTools, PrintScreen)
            document.addEventListener('keydown', (e)=>{
                const k = (e.key || '').toLowerCase();
                const ctrl = e.ctrlKey || e.metaKey;
                if (k==='f12' || k==='printscreen' || (ctrl && ['s','p','u','i','j','k','c','x','a'].includes(k)) || (e.ctrlKey && e.shiftKey && ['i','j','c'].includes(k))) {
                    e.preventDefault(); e.stopPropagation(); return false;
                }
            }, {capture:true});
            // Attempt to clear clipboard on PrintScreen (best-effort; OS screenshots still possible)
            document.addEventListener('keyup', (e)=>{
                if ((e.key||'').toLowerCase()==='printscreen') {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText('Screenshots are disabled').catch(()=>{});
                    }
                }
            });
            // Anti-embedding (clickjacking)
            try { if (window.top !== window.self) window.top.location = window.location; } catch(_){ /* ignore */ }
        })();
    </script>
    
    <!-- EVRENSEL SOHBET ARAYÜZÜ İÇİN JAVASCRIPT KODU -->
    <script>
        // --- DOM Elementleri ---
        const providerSelection = document.getElementById('provider-selection');
        const modelSelect = document.getElementById('model-select');
        const groqKeyContainer = document.getElementById('groq-key-container');
        const googleKeyContainer = document.getElementById('google-key-container');
        const groqApiKeyInput = document.getElementById('groq-api-key');
        const googleApiKeyInput = document.getElementById('google-api-key');
        const systemPromptInput = document.getElementById('system-prompt');
        const chatHistoryDiv = document.getElementById('chat-history');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const clearChatButton = document.getElementById('clear-chat');
        const loader = document.getElementById('loader');
        const errorMessageDiv = document.getElementById('error-message');
        const apiStatusDiv = document.getElementById('api-status');
const fetchKeysBtn = document.getElementById('fetch-keys-btn');
const toggleGroqKeyBtn = document.getElementById('toggle-groq-key');
const toggleGoogleKeyBtn = document.getElementById('toggle-google-key');

function toggleMask(inputEl, btnEl){
    inputEl.type = inputEl.type === 'password' ? 'text' : 'password';
    btnEl.classList.toggle('text-yellow-300');
}

        // --- Model Bilgileri ---
        const PROVIDERS = {
            groq: {
                name: 'Groq',
                apiEndpoint: 'https://api.groq.com/openai/v1/chat/completions',
                models: [
                    'llama-3.1-8b-instant',
                    'llama-3.3-70b-versatile',
                    'meta-llama/llama-guard-4-12b',
                    'openai/gpt-oss-120b',
                    'openai/gpt-oss-20b',
                    'deepseek-r1-distill-llama-70b',
                    'meta-llama/llama-4-maverick-17b-128e-instruct',
                    'meta-llama/llama-4-scout-17b-16e-instruct',
                    'meta-llama/llama-prompt-guard-2-22m',
                    'meta-llama/llama-prompt-guard-2-86m',
                    'moonshotai/kimi-k2-instruct',
                    'qwen/qwen3-32b',
                    'llama3-70b-8192', 
                    'llama3-8b-8192', 
                    'mixtral-8x7b-32768', 
                    'gemma-7b-it'
                ]
            },
            google: {
                name: 'Google',
                apiEndpoint: 'https://generativelanguage.googleapis.com/v1beta/models/',
                models: [
                    'gemini-2.5-pro',
                    'gemini-2.5-flash',
                    'gemini-2.5-flash-lite',
                    'gemini-1.5-pro',
                    'gemini-1.5-flash'
                ]
            }
        };

        let chatHistory = [];

        // --- Fonksiyonlar ---

        function updateModelList() {
            const selectedProvider = document.querySelector('input[name="provider"]:checked').value;
            modelSelect.innerHTML = '';
            PROVIDERS[selectedProvider].models.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = model;
                modelSelect.appendChild(option);
            });
            groqKeyContainer.classList.toggle('hidden', selectedProvider !== 'groq');
            googleKeyContainer.classList.toggle('hidden', selectedProvider !== 'google');
        }

        function addMessageToUI(role, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `max-w-xl lg:max-w-2xl px-4 py-2 rounded-lg text-white ${role === 'user' ? 'user-bubble' : 'assistant-bubble'}`;
            messageDiv.textContent = content;
            chatHistoryDiv.appendChild(messageDiv);
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
        }

        function showError(message) {
            errorMessageDiv.textContent = `Hata: ${message}`;
            errorMessageDiv.classList.remove('hidden');
        }

        function saveChatHistory() {
            localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
        }

        function loadChatHistory() {
            const savedHistory = localStorage.getItem('chatHistory');
            if (savedHistory) {
                chatHistory = JSON.parse(savedHistory);
                chatHistory.forEach(msg => addMessageToUI(msg.role, msg.content));
            }
        }
        
        // YENİ FONKSİYON: Kaydedilmiş ayarları (API anahtarları) yükler
        function loadSettings() {
            const savedGroqKey = localStorage.getItem('groqApiKey');
            if (savedGroqKey) {
                groqApiKeyInput.value = savedGroqKey;
            }
            const savedGoogleKey = localStorage.getItem('googleApiKey');
            if (savedGoogleKey) {
                googleApiKeyInput.value = savedGoogleKey;
            }
        }

        async function handleSend() {
            const selectedProvider = document.querySelector('input[name="provider"]:checked').value;
            const selectedModel = modelSelect.value;
            const apiKey = selectedProvider === 'groq' ? groqApiKeyInput.value.trim() : googleApiKeyInput.value.trim();
            const systemPrompt = systemPromptInput.value.trim();
            const userMessage = userInput.value.trim();

            if (!apiKey) {
                showError(`Lütfen ${PROVIDERS[selectedProvider].name} API anahtarınızı girin.`);
                return;
            }
            if (!userMessage) return;

            sendButton.disabled = true;
            userInput.value = '';
            loader.classList.remove('hidden');
            errorMessageDiv.classList.add('hidden');
            
            addMessageToUI('user', userMessage);
            chatHistory.push({ role: 'user', content: userMessage });

            const conversationContext = chatHistory.slice(-11, -1); 
            
            let apiEndpoint = PROVIDERS[selectedProvider].apiEndpoint;
            let headers = { 'Content-Type': 'application/json' };
            let body;

            if (selectedProvider === 'groq') {
                headers['Authorization'] = `Bearer ${apiKey}`;
                let messages = [];

                const isClassificationModel = [
                    'meta-llama/llama-guard-4-12b',
                    'meta-llama/llama-prompt-guard-2-22m',
                    'meta-llama/llama-prompt-guard-2-86m'
                ].includes(selectedModel);

                if (isClassificationModel) {
                    messages.push({ role: 'user', content: userMessage });
                } else {
                    if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push(...conversationContext); 
                    messages.push({ role: 'user', content: userMessage });
                }
                
                body = JSON.stringify({
                    model: selectedModel,
                    messages: messages
                });

            } else if (selectedProvider === 'google') {
                apiEndpoint += `${selectedModel}:generateContent?key=${apiKey}`;
                
                const contents = conversationContext.map(msg => ({
                    role: msg.role === 'assistant' ? 'model' : 'user',
                    parts: [{ text: msg.content }]
                }));
                contents.push({ role: 'user', parts: [{ text: userMessage }] });

                let payload = { contents };
                if (systemPrompt) {
                    payload.systemInstruction = { parts: [{ text: systemPrompt }] };
                }
                body = JSON.stringify(payload);
            }

            try {
                const response = await fetch(apiEndpoint, { method: 'POST', headers, body });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP hatası! Durum: ${response.status}`);
                }
                const data = await response.json();
                
                let assistantMessage;
                if (selectedProvider === 'groq') {
                    assistantMessage = data.choices[0]?.message?.content;
                } else if (selectedProvider === 'google') {
                    assistantMessage = data.candidates[0]?.content?.parts[0]?.text;
                }

                if (assistantMessage) {
                    addMessageToUI('assistant', assistantMessage.trim());
                    chatHistory.push({ role: 'assistant', content: assistantMessage.trim() });
                    saveChatHistory();
                } else {
                    showError("API'den geçerli bir yanıt alınamadı.");
                }

            } catch (error) {
                console.error("API Hatası:", error);
                showError(error.message);
                chatHistory.pop(); 
            } finally {
                sendButton.disabled = false;
                loader.classList.add('hidden');
            }
        }

        // --- Event Listeners ---
        providerSelection.addEventListener('change', updateModelList);
        sendButton.addEventListener('click', handleSend);
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSend();
            }
        });
        clearChatButton.addEventListener('click', () => {
            chatHistory = [];
            chatHistoryDiv.innerHTML = '';
            localStorage.removeItem('chatHistory');
        });

        // YENİ EVENT LISTENERS: API anahtarlarını yazıldıkça kaydeder
        groqApiKeyInput.addEventListener('input', () => {
            localStorage.setItem('groqApiKey', groqApiKeyInput.value);
        });
        googleApiKeyInput.addEventListener('input', () => {
            localStorage.setItem('googleApiKey', googleApiKeyInput.value);
        });

        // --- Başlangıç ---
        updateModelList();
        loadChatHistory();
        loadSettings(); // YENİ: Kaydedilmiş ayarları yükle

    </script>


    <script>
        // --- Three.js Sahne Kurulumu ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('bg-canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.position.z = 250; // Başlangıçta kamera daha uzakta

        // --- Parçacık Sistemi ---
        const particleCount = 15000; // Daha fazla parçacıkla daha yoğun bir etki
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const color = new THREE.Color();

        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() * 2 - 1) * 300;
            positions[i * 3 + 1] = (Math.random() * 2 - 1) * 300;
            positions[i * 3 + 2] = (Math.random() * 2 - 1) * 300;
            color.set(Math.random() > 0.3 ? 0x22d3ee : 0xffffff); // Daha fazla cyan rengi
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
            sizes[i] = Math.random() * 2.0 + 0.5;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const material = new THREE.ShaderMaterial({
            uniforms: {
                pointTexture: { value: new THREE.TextureLoader().load(`data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMiIgZmlsbD0iI2ZmZiIvPjwvc3ZnPg==`) },
                // YENİ: Çıkış animasyonu için genel opaklık
                globalOpacity: { value: 1.0 }
            },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                    gl_PointSize = size * ( 300.0 / -mvPosition.z );
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                uniform float globalOpacity; // Yeni uniform
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4( vColor, 1.0 );
                    gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                    gl_FragColor.a *= globalOpacity; // Genel opaklığı uygula
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- YENİ: Fare Etkileşimi ---
        const mouse = new THREE.Vector2(10000, 10000);
        window.addEventListener('mousemove', (event) => {
            // Fare pozisyonunu -1 ile 1 arasında normalize et
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // --- Animasyon Döngüsü ---
        const clock = new THREE.Clock();
        function animate() {
            const elapsedTime = clock.getElapsedTime();
            requestAnimationFrame(animate);
            
            // YENİ: Fare pozisyonuna göre sahneyi yavaşça döndür
            // Bu, parçacıkların fareyi takip ettiği hissini verir
            scene.rotation.y = THREE.MathUtils.lerp(scene.rotation.y, mouse.x * 0.2, 0.05);
            scene.rotation.x = THREE.MathUtils.lerp(scene.rotation.x, -mouse.y * 0.2, 0.05);

            renderer.render(scene, camera);
        }
        animate();

        // --- Pencere Boyutlandırma ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- YENİ: Geliştirilmiş GSAP Giriş Animasyonu ---
        const tl = gsap.timeline();

        // 1. Adım: Kamera parçacıkların içine doğru yaklaşır
        tl.to(camera.position, {
            duration: 4,
            z: 70,
            ease: "power3.inOut"
        }, 0);

        // 2. Adım: Parçacıklar yavaşça dönerken toplanır
        tl.to(particles.rotation, {
            duration: 4,
            y: Math.PI * 0.5,
            ease: "power2.inOut"
        }, 0);

        // 3. Adım: UI konteynerini göster
        tl.to("#ui-container", {
            duration: 2,
            opacity: 1,
            ease: "power2.out"
        }, 2); 

        // 4. Adım: Alt başlığı göster
        tl.to("#subtitle", {
            duration: 2,
            opacity: 1,
            ease: "power2.out"
        }, 2.2);

        // 5. Adım: Giriş butonunu göster
        tl.to("#enter-button", {
            duration: 1.5,
            opacity: 1,
            scale: 1,
            ease: "elastic.out(1, 0.5)"
        }, 2.5);

        // --- YENİ: Geliştirilmiş Buton Tıklama Olayı ---
        const enterButton = document.getElementById('enter-button');
        const introContainer = document.getElementById('intro-container');
        
        enterButton.addEventListener('click', () => {
            const tlExit = gsap.timeline({
                onComplete: () => {
                    // Animasyon bitince konteyneri DOM'dan kaldır
                    introContainer.style.display = 'none';
                }
            });

            // UI elemanlarını ve parçacıkları aynı anda kaybet
            tlExit.to("#ui-container", {
                duration: 0.5,
                opacity: 0,
                ease: "power2.in"
            }, 0);

            // Parçacıkları "hiperuzay sıçraması" efektiyle ileri fırlat
            tlExit.to(particles.position, {
                duration: 1.2,
                z: 400,
                ease: "power3.in"
            }, 0);

            // Parçacıkların opaklığını azaltarak kaybolmalarını sağla
            tlExit.to(particles.material.uniforms.globalOpacity, {
                duration: 1.2,
                value: 0,
                ease: "power3.in"
            }, 0);
        });

    </script>
    <script type="module" src="js/exoplanet-map.js"></script>
    <script type="module" src="js/nasa-apod.js"></script>
    <script type="module" src="js/intro-animation.js"></script>
<script src="js/kaira-debug-toggle.js"></script>
<script src="js/form-input-safety.js"></script>
<script type="module" src="js/system-prompt.js"></script>
</body>
</html>
